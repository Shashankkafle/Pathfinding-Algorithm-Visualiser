{"ast":null,"code":"import { getAllNodes, getUnvisitedNeighborsforAstar, sortNodesByDistance, findCost, updateUnvisitedNeighborsforastar } from \"./AlgoTools\";\nexport function aStar(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  startNode.cost = 0;\n  var unvisitedNodes = [];\n  var visitedNodes = [];\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length > 0) {\n    var cheapestIndex = 0,\n        cheapestNode = unvisitedNodes[0];\n\n    for (var i = 0; i < unvisitedNodes.length; i++) {\n      if (unvisitedNodes[i].cost < cheapestNode.cost) {\n        cheapestIndex = i;\n      }\n    }\n\n    cheapestNode = unvisitedNodes[cheapestIndex];\n    unvisitedNodes.splice(cheapestIndex, 1);\n    visitedNodes.push(cheapestNode);\n\n    if (cheapestNode.isFinish) {\n      console.log(visitedNodes[0]);\n      return visitedNodes;\n    }\n\n    unvisitedNodes.splice(cheapestIndex, 1);\n    visitedNodes.push(cheapestNode);\n    var unvisitedNeighbours = getUnvisitedNeighborsforAstar(cheapestNode, grid);\n\n    for (var i = 0; i < unvisitedNeighbours.length; i++) {\n      if (!visitedNodes.includes(unvisitedNeighbours[i]) && !unvisitedNeighbours[i].isWall) {\n        var tempdist = cheapestNode.distance + 1;\n        var newPath = false;\n\n        if (unvisitedNodes.includes(unvisitedNeighbours[i])) {\n          if (tempdist < unvisitedNeighbours[i].distance) {\n            unvisitedNeighbours[i].distance = tempdist;\n            newPath = true;\n          }\n        } else {\n          unvisitedNeighbours[i].distance = tempdist;\n          newPath = true;\n          unvisitedNodes.push(unvisitedNeighbours[i]);\n        }\n\n        if (newPath) {\n          findCost(unvisitedNeighbours[i], finishNode);\n          unvisitedNeighbours[i].previous = cheapestNode;\n        }\n\n        findCost(unvisitedNeighbours[i], finishNode);\n      }\n    }\n  }\n\n  return null;\n}","map":{"version":3,"sources":["C:/Users/Acer/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/Astar.jsx"],"names":["getAllNodes","getUnvisitedNeighborsforAstar","sortNodesByDistance","findCost","updateUnvisitedNeighborsforastar","aStar","grid","startNode","finishNode","distance","cost","unvisitedNodes","visitedNodes","push","length","cheapestIndex","cheapestNode","i","splice","isFinish","console","log","unvisitedNeighbours","includes","isWall","tempdist","newPath","previous"],"mappings":"AAAA,SAAQA,WAAR,EAAoBC,6BAApB,EAAkDC,mBAAlD,EAAsEC,QAAtE,EAA+EC,gCAA/E,QAAuH,aAAvH;AAEA,OAAO,SAASC,KAAT,CAAeC,IAAf,EAAqBC,SAArB,EAAgCC,UAAhC,EACP;AAEID,EAAAA,SAAS,CAACE,QAAV,GAAqB,CAArB;AACAF,EAAAA,SAAS,CAACG,IAAV,GAAiB,CAAjB;AAEA,MAAIC,cAAc,GAAC,EAAnB;AAEA,MAAIC,YAAY,GAAC,EAAjB;AACAD,EAAAA,cAAc,CAACE,IAAf,CAAoBN,SAApB;;AAIA,SAAMI,cAAc,CAACG,MAAf,GAAsB,CAA5B,EACA;AAAO,QAAIC,aAAa,GAAC,CAAlB;AAAA,QAAoBC,YAAY,GAACL,cAAc,CAAC,CAAD,CAA/C;;AAEF,SAAI,IAAIM,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACN,cAAc,CAACG,MAA7B,EAAoCG,CAAC,EAArC,EACD;AACI,UAAGN,cAAc,CAACM,CAAD,CAAd,CAAkBP,IAAlB,GAAuBM,YAAY,CAACN,IAAvC,EACA;AAEIK,QAAAA,aAAa,GAACE,CAAd;AACH;AACJ;;AAEDD,IAAAA,YAAY,GAACL,cAAc,CAACI,aAAD,CAA3B;AACAJ,IAAAA,cAAc,CAACO,MAAf,CAAsBH,aAAtB,EAAoC,CAApC;AACAH,IAAAA,YAAY,CAACC,IAAb,CAAkBG,YAAlB;;AACA,QAAGA,YAAY,CAACG,QAAhB,EACA;AAAEC,MAAAA,OAAO,CAACC,GAAR,CAAYT,YAAY,CAAC,CAAD,CAAxB;AACE,aAAOA,YAAP;AACH;;AACDD,IAAAA,cAAc,CAACO,MAAf,CAAsBH,aAAtB,EAAoC,CAApC;AACAH,IAAAA,YAAY,CAACC,IAAb,CAAkBG,YAAlB;AAGA,QAAIM,mBAAmB,GAACrB,6BAA6B,CAACe,YAAD,EAAcV,IAAd,CAArD;;AAEA,SAAI,IAAIW,CAAC,GAAC,CAAV,EAAYA,CAAC,GAACK,mBAAmB,CAACR,MAAlC,EAAyCG,CAAC,EAA1C,EACA;AAEI,UAAG,CAACL,YAAY,CAACW,QAAb,CAAsBD,mBAAmB,CAACL,CAAD,CAAzC,CAAD,IAAiD,CAACK,mBAAmB,CAACL,CAAD,CAAnB,CAAuBO,MAA5E,EACA;AACI,YAAIC,QAAQ,GAACT,YAAY,CAACP,QAAb,GAAsB,CAAnC;AACA,YAAIiB,OAAO,GAAG,KAAd;;AACA,YAAGf,cAAc,CAACY,QAAf,CAAwBD,mBAAmB,CAACL,CAAD,CAA3C,CAAH,EACA;AACI,cAAGQ,QAAQ,GAACH,mBAAmB,CAACL,CAAD,CAAnB,CAAuBR,QAAnC,EACA;AACIa,YAAAA,mBAAmB,CAACL,CAAD,CAAnB,CAAuBR,QAAvB,GAAgCgB,QAAhC;AACAC,YAAAA,OAAO,GAAC,IAAR;AACH;AACJ,SAPD,MASA;AACIJ,UAAAA,mBAAmB,CAACL,CAAD,CAAnB,CAAuBR,QAAvB,GAAgCgB,QAAhC;AACAC,UAAAA,OAAO,GAAC,IAAR;AACAf,UAAAA,cAAc,CAACE,IAAf,CAAoBS,mBAAmB,CAACL,CAAD,CAAvC;AACH;;AACD,YAAGS,OAAH,EAAW;AACRvB,UAAAA,QAAQ,CAACmB,mBAAmB,CAACL,CAAD,CAApB,EAAwBT,UAAxB,CAAR;AACAc,UAAAA,mBAAmB,CAACL,CAAD,CAAnB,CAAuBU,QAAvB,GAAiCX,YAAjC;AACF;;AACDb,QAAAA,QAAQ,CAACmB,mBAAmB,CAACL,CAAD,CAApB,EAAwBT,UAAxB,CAAR;AACH;AAEJ;AAKJ;;AACD,SAAO,IAAP;AACH","sourcesContent":["import {getAllNodes,getUnvisitedNeighborsforAstar,sortNodesByDistance,findCost,updateUnvisitedNeighborsforastar } from \"./AlgoTools\";\r\n\r\nexport function aStar(grid, startNode, finishNode)\r\n{\r\n   \r\n    startNode.distance = 0;\r\n    startNode.cost = 0\r\n\r\n    var unvisitedNodes=[]\r\n\r\n    var visitedNodes=[] \r\n    unvisitedNodes.push(startNode)\r\n   \r\n   \r\n\r\n    while(unvisitedNodes.length>0)\r\n    {      var cheapestIndex=0,cheapestNode=unvisitedNodes[0]         \r\n       \r\n         for(var i=0;i<unvisitedNodes.length;i++) \r\n        { \r\n            if(unvisitedNodes[i].cost<cheapestNode.cost)\r\n            { \r\n                \r\n                cheapestIndex=i\r\n            }\r\n        }\r\n       \r\n        cheapestNode=unvisitedNodes[cheapestIndex]\r\n        unvisitedNodes.splice(cheapestIndex,1)\r\n        visitedNodes.push(cheapestNode) \r\n        if(cheapestNode.isFinish)\r\n        { console.log(visitedNodes[0])\r\n            return(visitedNodes)\r\n        }  \r\n        unvisitedNodes.splice(cheapestIndex,1)  \r\n        visitedNodes.push(cheapestNode)\r\n        \r\n       \r\n        var unvisitedNeighbours=getUnvisitedNeighborsforAstar(cheapestNode,grid)  \r\n        \r\n        for(var i=0;i<unvisitedNeighbours.length;i++) \r\n        {          \r\n           \r\n            if(!visitedNodes.includes(unvisitedNeighbours[i])&&(!unvisitedNeighbours[i].isWall))\r\n            {\r\n                var tempdist=cheapestNode.distance+1\r\n                var newPath = false;\r\n                if(unvisitedNodes.includes(unvisitedNeighbours[i]))\r\n                {\r\n                    if(tempdist<unvisitedNeighbours[i].distance)\r\n                    {\r\n                        unvisitedNeighbours[i].distance=tempdist\r\n                        newPath=true\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    unvisitedNeighbours[i].distance=tempdist\r\n                    newPath=true\r\n                    unvisitedNodes.push(unvisitedNeighbours[i])\r\n                }\r\n                if(newPath){\r\n                   findCost(unvisitedNeighbours[i],finishNode)\r\n                   unvisitedNeighbours[i].previous= cheapestNode\r\n                }\r\n                findCost(unvisitedNeighbours[i],finishNode)\r\n            }\r\n           \r\n        }\r\n        \r\n       \r\n        \r\n          \r\n    }\r\n    return null\r\n}"]},"metadata":{},"sourceType":"module"}