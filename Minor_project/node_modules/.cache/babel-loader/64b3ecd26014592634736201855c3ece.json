{"ast":null,"code":"import { getUnvisitedNeighbors } from './AlgoTools';\nexport function unweightedSearchAlgorithm(grid, startNode, finishNode, name) {\n  console.log(name);\n  const queue = [];\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    let currentNode = name === \"bfs\" ? queue.shift() : queue.pop();\n    if (currentNode.isWall) continue;\n    queue.push(currentNode);\n    currentNode.isVisited = true;\n\n    if (currentNode === finishNode) {\n      return queue;\n    }\n\n    let edges = getUnvisitedNeighbors(currentNode, grid, name);\n\n    for (let i = 0; i < edges.length; i++) {\n      let neighbor = edges[i];\n\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return queue;\n} // function getUnvisitedNeighbors(node, grid, name) {\n//   const neighbors = [];\n//   const {col, row} = node;\n//   if (row > 0) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row - 1][col]);\n//     } else {\n//       neighbors.unshift(grid[row - 1][col]);\n//     }\n//   }\n//   if (row < grid.length - 1) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row + 1][col]);\n//     } else {\n//       neighbors.unshift(grid[row + 1][col]);\n//     }\n//   } \n//   if (col > 0) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row][col - 1]);\n//     } else {\n//       neighbors.unshift(grid[row][col - 1]);\n//     }\n//   } \n//   if (col < grid[0].length - 1) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row][col + 1]);\n//     } else {\n//       neighbors.unshift(grid[row][col + 1]);\n//     }\n//   }\n//   return neighbors.filter(neighbor => !neighbor.isVisited);\n// }","map":{"version":3,"sources":["E:/minor project/Pathfinding-Algorithm-visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["getUnvisitedNeighbors","unweightedSearchAlgorithm","grid","startNode","finishNode","name","console","log","queue","push","length","currentNode","shift","pop","isWall","isVisited","edges","i","neighbor","previousNode"],"mappings":"AAAA,SAAQA,qBAAR,QAAoC,aAApC;AAEA,OAAO,SAASC,yBAAT,CAAmCC,IAAnC,EAAwCC,SAAxC,EAAkDC,UAAlD,EAA6DC,IAA7D,EAAmE;AACxEC,EAAAA,OAAO,CAACC,GAAR,CAAYF,IAAZ;AACA,QAAMG,KAAK,GAAG,EAAd;AACAA,EAAAA,KAAK,CAACC,IAAN,CAAWN,SAAX;;AAEA,SAAMK,KAAK,CAACE,MAAN,GAAe,CAArB,EAAwB;AACtB,QAAIC,WAAW,GAAIN,IAAI,KAAK,KAAT,GAAiBG,KAAK,CAACI,KAAN,EAAjB,GAAiCJ,KAAK,CAACK,GAAN,EAApD;AACA,QAAGF,WAAW,CAACG,MAAf,EAAuB;AACvBN,IAAAA,KAAK,CAACC,IAAN,CAAWE,WAAX;AACAA,IAAAA,WAAW,CAACI,SAAZ,GAAwB,IAAxB;;AACA,QAAGJ,WAAW,KAAKP,UAAnB,EAA+B;AAC7B,aAAOI,KAAP;AACD;;AACD,QAAIQ,KAAK,GAAGhB,qBAAqB,CAACW,WAAD,EAAcT,IAAd,EAAoBG,IAApB,CAAjC;;AACA,SAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,KAAK,CAACN,MAA1B,EAAkCO,CAAC,EAAnC,EAAsC;AACpC,UAAIC,QAAQ,GAAGF,KAAK,CAACC,CAAD,CAApB;;AACA,UAAG,CAACC,QAAQ,CAACH,SAAb,EAAwB;AACtBG,QAAAA,QAAQ,CAACH,SAAT,GAAqB,IAArB;AACAG,QAAAA,QAAQ,CAACC,YAAT,GAAwBR,WAAxB;AACAH,QAAAA,KAAK,CAACC,IAAN,CAAWS,QAAX;AACD;AACF;AACF;;AACD,SAAOV,KAAP;AACD,C,CAGD;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import {getUnvisitedNeighbors} from './AlgoTools';\r\n\r\nexport function unweightedSearchAlgorithm(grid,startNode,finishNode,name) {\r\n  console.log(name);\r\n  const queue = [];\r\n  queue.push(startNode);\r\n\r\n  while(queue.length > 0) {\r\n    let currentNode  = name === \"bfs\" ? queue.shift() : queue.pop(); \r\n    if(currentNode.isWall) continue;\r\n    queue.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode === finishNode) {\r\n      return queue;\r\n    }\r\n    let edges = getUnvisitedNeighbors(currentNode, grid, name);\r\n    for (let i = 0; i < edges.length; i++){\r\n      let neighbor = edges[i];\r\n      if(!neighbor.isVisited) {\r\n        neighbor.isVisited = true;\r\n        neighbor.previousNode = currentNode;\r\n        queue.push(neighbor);\r\n      }\r\n    } \r\n  }\r\n  return queue;\r\n}\r\n\r\n\r\n// function getUnvisitedNeighbors(node, grid, name) {\r\n//   const neighbors = [];\r\n//   const {col, row} = node;\r\n\r\n//   if (row > 0) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row - 1][col]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row - 1][col]);\r\n//     }\r\n//   }\r\n\r\n//   if (row < grid.length - 1) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row + 1][col]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row + 1][col]);\r\n//     }\r\n//   } \r\n\r\n//   if (col > 0) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row][col - 1]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row][col - 1]);\r\n//     }\r\n//   } \r\n\r\n//   if (col < grid[0].length - 1) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row][col + 1]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row][col + 1]);\r\n//     }\r\n//   }\r\n//   return neighbors.filter(neighbor => !neighbor.isVisited);\r\n// }\r\n\r\n"]},"metadata":{},"sourceType":"module"}