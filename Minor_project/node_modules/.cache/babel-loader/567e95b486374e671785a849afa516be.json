{"ast":null,"code":"import{getUnvisitedNeighborsforAstar,findCost}from\"./AlgoTools\";export function aStar(grid,startNode,finishNode){startNode.distance=0;startNode.cost=0;var unvisitedNodes=[];var visitedNodes=[];unvisitedNodes.push(startNode);while(unvisitedNodes.length>0){var cheapestIndex=0,cheapestNode=unvisitedNodes[0];for(var i=0;i<unvisitedNodes.length;i++){if(unvisitedNodes[i].cost<cheapestNode.cost){cheapestIndex=i;}}cheapestNode=unvisitedNodes[cheapestIndex];if(cheapestNode.isFinish){visitedNodes.push(finishNode);return visitedNodes;}unvisitedNodes.splice(cheapestIndex,1);visitedNodes.push(cheapestNode);var unvisitedNeighbours=getUnvisitedNeighborsforAstar(cheapestNode,grid);for(var i=0;i<unvisitedNeighbours.length;i++){if(!visitedNodes.includes(unvisitedNeighbours[i])){var tempdist=cheapestNode.distance+1;var newPath=false;if(unvisitedNodes.includes(unvisitedNeighbours[i])){if(tempdist<unvisitedNeighbours[i].distance){unvisitedNeighbours[i].distance=tempdist;newPath=true;}}else{unvisitedNeighbours[i].distance=tempdist;newPath=true;unvisitedNodes.push(unvisitedNeighbours[i]);}if(newPath){findCost(unvisitedNeighbours[i],finishNode);unvisitedNeighbours[i].previousNode=cheapestNode;}findCost(unvisitedNeighbours[i],finishNode);}}}return visitedNodes;}","map":{"version":3,"sources":["C:/Users/Acer/Pathfinding-Algorithm-Visualiser/minor_project/src/Algorithms/Astar.jsx"],"names":["getUnvisitedNeighborsforAstar","findCost","aStar","grid","startNode","finishNode","distance","cost","unvisitedNodes","visitedNodes","push","length","cheapestIndex","cheapestNode","i","isFinish","splice","unvisitedNeighbours","includes","tempdist","newPath","previousNode"],"mappings":"AAAA,OAAQA,6BAAR,CAAsCC,QAAtC,KAAsD,aAAtD,CAEA,MAAO,SAASC,CAAAA,KAAT,CAAeC,IAAf,CAAqBC,SAArB,CAAgCC,UAAhC,CACP,CAAID,SAAS,CAACE,QAAV,CAAqB,CAArB,CACAF,SAAS,CAACG,IAAV,CAAiB,CAAjB,CACA,GAAIC,CAAAA,cAAc,CAAC,EAAnB,CACA,GAAIC,CAAAA,YAAY,CAAC,EAAjB,CACAD,cAAc,CAACE,IAAf,CAAoBN,SAApB,EACA,MAAMI,cAAc,CAACG,MAAf,CAAsB,CAA5B,CACA,CAAO,GAAIC,CAAAA,aAAa,CAAC,CAAlB,CAAoBC,YAAY,CAACL,cAAc,CAAC,CAAD,CAA/C,CACF,IAAI,GAAIM,CAAAA,CAAC,CAAC,CAAV,CAAYA,CAAC,CAACN,cAAc,CAACG,MAA7B,CAAoCG,CAAC,EAArC,CACD,CACI,GAAGN,cAAc,CAACM,CAAD,CAAd,CAAkBP,IAAlB,CAAuBM,YAAY,CAACN,IAAvC,CACA,CACIK,aAAa,CAACE,CAAd,CACH,CACJ,CACDD,YAAY,CAACL,cAAc,CAACI,aAAD,CAA3B,CACA,GAAGC,YAAY,CAACE,QAAhB,CACA,CAAEN,YAAY,CAACC,IAAb,CAAkBL,UAAlB,EACE,MAAOI,CAAAA,YAAP,CACH,CACDD,cAAc,CAACQ,MAAf,CAAsBJ,aAAtB,CAAoC,CAApC,EACAH,YAAY,CAACC,IAAb,CAAkBG,YAAlB,EACA,GAAII,CAAAA,mBAAmB,CAACjB,6BAA6B,CAACa,YAAD,CAAcV,IAAd,CAArD,CAEA,IAAI,GAAIW,CAAAA,CAAC,CAAC,CAAV,CAAYA,CAAC,CAACG,mBAAmB,CAACN,MAAlC,CAAyCG,CAAC,EAA1C,CACA,CACI,GAAG,CAACL,YAAY,CAACS,QAAb,CAAsBD,mBAAmB,CAACH,CAAD,CAAzC,CAAJ,CACA,CACI,GAAIK,CAAAA,QAAQ,CAACN,YAAY,CAACP,QAAb,CAAsB,CAAnC,CACA,GAAIc,CAAAA,OAAO,CAAG,KAAd,CACA,GAAGZ,cAAc,CAACU,QAAf,CAAwBD,mBAAmB,CAACH,CAAD,CAA3C,CAAH,CACA,CACI,GAAGK,QAAQ,CAACF,mBAAmB,CAACH,CAAD,CAAnB,CAAuBR,QAAnC,CACA,CACIW,mBAAmB,CAACH,CAAD,CAAnB,CAAuBR,QAAvB,CAAgCa,QAAhC,CACAC,OAAO,CAAC,IAAR,CACH,CACJ,CAPD,IASA,CACIH,mBAAmB,CAACH,CAAD,CAAnB,CAAuBR,QAAvB,CAAgCa,QAAhC,CACAC,OAAO,CAAC,IAAR,CACAZ,cAAc,CAACE,IAAf,CAAoBO,mBAAmB,CAACH,CAAD,CAAvC,EACH,CACD,GAAGM,OAAH,CAAW,CACRnB,QAAQ,CAACgB,mBAAmB,CAACH,CAAD,CAApB,CAAwBT,UAAxB,CAAR,CACAY,mBAAmB,CAACH,CAAD,CAAnB,CAAuBO,YAAvB,CAAqCR,YAArC,CACF,CACDZ,QAAQ,CAACgB,mBAAmB,CAACH,CAAD,CAApB,CAAwBT,UAAxB,CAAR,CACH,CACJ,CACJ,CAED,MAAOI,CAAAA,YAAP,CAEH","sourcesContent":["import {getUnvisitedNeighborsforAstar,findCost } from \"./AlgoTools\";\r\n\r\nexport function aStar(grid, startNode, finishNode)\r\n{   startNode.distance = 0;\r\n    startNode.cost = 0\r\n    var unvisitedNodes=[]\r\n    var visitedNodes=[] \r\n    unvisitedNodes.push(startNode)\r\n    while(unvisitedNodes.length>0)\r\n    {      var cheapestIndex=0,cheapestNode=unvisitedNodes[0]         \r\n         for(var i=0;i<unvisitedNodes.length;i++) \r\n        { \r\n            if(unvisitedNodes[i].cost<cheapestNode.cost)\r\n            {      \r\n                cheapestIndex=i\r\n            }\r\n        }\r\n        cheapestNode=unvisitedNodes[cheapestIndex]\r\n        if(cheapestNode.isFinish)\r\n        { visitedNodes.push(finishNode)\r\n            return(visitedNodes)\r\n        }  \r\n        unvisitedNodes.splice(cheapestIndex,1)  \r\n        visitedNodes.push(cheapestNode)\r\n        var unvisitedNeighbours=getUnvisitedNeighborsforAstar(cheapestNode,grid) \r\n      \r\n        for(var i=0;i<unvisitedNeighbours.length;i++) \r\n        {          \r\n            if(!visitedNodes.includes(unvisitedNeighbours[i]))\r\n            {\r\n                var tempdist=cheapestNode.distance+1\r\n                var newPath = false;\r\n                if(unvisitedNodes.includes(unvisitedNeighbours[i]))\r\n                {\r\n                    if(tempdist<unvisitedNeighbours[i].distance)\r\n                    {\r\n                        unvisitedNeighbours[i].distance=tempdist\r\n                        newPath=true\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    unvisitedNeighbours[i].distance=tempdist\r\n                    newPath=true\r\n                    unvisitedNodes.push(unvisitedNeighbours[i])\r\n                }\r\n                if(newPath){\r\n                   findCost(unvisitedNeighbours[i],finishNode)\r\n                   unvisitedNeighbours[i].previousNode= cheapestNode\r\n                }\r\n                findCost(unvisitedNeighbours[i],finishNode)\r\n            } \r\n        }      \r\n    }\r\n   \r\n    return visitedNodes\r\n    \r\n}"]},"metadata":{},"sourceType":"module"}