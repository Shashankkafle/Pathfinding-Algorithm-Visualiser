{"ast":null,"code":"import { getAllNodes, updateUnvisitedNeighbors } from './AlgoTools';\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift(); // If we encounter a wall, we skip it.\n\n    if (closestNode.isWall) continue; // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}","map":{"version":3,"sources":["E:/minor project/Pathfinding-Algorithm-visualiser/Minor_project/src/Algorithms/Algorithm.jsx"],"names":["getAllNodes","updateUnvisitedNeighbors","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","push","sort","nodeA","nodeB"],"mappings":"AAAA,SAAQA,WAAR,EAAoBC,wBAApB,QAAoD,aAApD;AAGA,OAAO,SAASC,QAAT,CAAkBC,IAAlB,EAAwBC,SAAxB,EAAmCC,UAAnC,EAA+C;AAClD,QAAMC,mBAAmB,GAAG,EAA5B;AACAF,EAAAA,SAAS,CAACG,QAAV,GAAqB,CAArB;AACA,QAAMC,cAAc,GAAGR,WAAW,CAACG,IAAD,CAAlC;;AACA,SAAO,CAAC,CAACK,cAAc,CAACC,MAAxB,EAAgC;AAC9BC,IAAAA,mBAAmB,CAACF,cAAD,CAAnB;AACA,UAAMG,WAAW,GAAGH,cAAc,CAACI,KAAf,EAApB,CAF8B,CAG9B;;AACA,QAAID,WAAW,CAACE,MAAhB,EAAwB,SAJM,CAK9B;AACA;;AACA,QAAIF,WAAW,CAACJ,QAAZ,KAAyBO,QAA7B,EAAuC,OAAOR,mBAAP;AACvCK,IAAAA,WAAW,CAACI,SAAZ,GAAwB,IAAxB;AACAT,IAAAA,mBAAmB,CAACU,IAApB,CAAyBL,WAAzB;AACA,QAAIA,WAAW,KAAKN,UAApB,EAAgC,OAAOC,mBAAP;AAChCL,IAAAA,wBAAwB,CAACU,WAAD,EAAcR,IAAd,CAAxB;AACD;AACF;;AAED,SAASO,mBAAT,CAA6BF,cAA7B,EAA6C;AAC3CA,EAAAA,cAAc,CAACS,IAAf,CAAoB,CAACC,KAAD,EAAQC,KAAR,KAAkBD,KAAK,CAACX,QAAN,GAAiBY,KAAK,CAACZ,QAA7D;AACD","sourcesContent":["import {getAllNodes,updateUnvisitedNeighbors } from './AlgoTools';\r\n\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    startNode.distance = 0;\r\n    const unvisitedNodes = getAllNodes(grid);\r\n    while (!!unvisitedNodes.length) {\r\n      sortNodesByDistance(unvisitedNodes);\r\n      const closestNode = unvisitedNodes.shift();\r\n      // If we encounter a wall, we skip it.\r\n      if (closestNode.isWall) continue;\r\n      // If the closest node is at a distance of infinity,\r\n      // we must be trapped and should therefore stop.\r\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\r\n      closestNode.isVisited = true;\r\n      visitedNodesInOrder.push(closestNode);\r\n      if (closestNode === finishNode) return visitedNodesInOrder;\r\n      updateUnvisitedNeighbors(closestNode, grid);\r\n    }\r\n  }\r\n\r\n  function sortNodesByDistance(unvisitedNodes) {\r\n    unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n  }\r\n\r\n  "]},"metadata":{},"sourceType":"module"}