{"ast":null,"code":"export function unweightedSearchAlgorithm(grid, startNode, finishNode) {\n  const queue = [];\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    let currentNode; // if(name === 'bfs'){\n    //   currentNode = queue.shift();\n    // }\n\n    currentNode = queue.shift(); // else{\n    //   currentNode = queue.pop();\n    // }\n\n    if (currentNode.isWall) continue; // if(name === 'bfs'){\n    //   queue.push(currentNode);\n    // }\n\n    queue.push(currentNode);\n    currentNode.isVisited = true;\n\n    if (currentNode === finishNode) {\n      return queue;\n    }\n\n    let edges = getUnvisitedNeighbors(grid, currentNode);\n\n    for (let i = 0; i < edges.length; i++) {\n      let neighbor = edges[i];\n\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    } // console.log('queue')\n    // console.log(queue.length)\n    //     console.log(queue)\n\n  }\n\n  return queue;\n} // function getUnvisitedNeighbors(node, grid, name) {\n//   const neighbors = [];\n//   const {col, row} = node;\n//   if (row > 0) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row - 1][col]);\n//     } else {\n//       neighbors.unshift(grid[row - 1][col]);\n//     }\n//   }\n//   if (row < grid.length - 1) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row + 1][col]);\n//     } else {\n//       neighbors.unshift(grid[row + 1][col]);\n//     }\n//   } \n//   if (col > 0) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row][col - 1]);\n//     } else {\n//       neighbors.unshift(grid[row][col - 1]);\n//     }\n//   } \n//   if (col < grid[0].length - 1) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row][col + 1]);\n//     } else {\n//       neighbors.unshift(grid[row][col + 1]);\n//     }\n//   }\n//   return neighbors.filter(neighbor => !neighbor.isVisited);\n// }\n\nfunction getUnvisitedNeighbors(grid, node) {\n  const ROWS = grid.length;\n  const COLS = grid[0].length;\n  const {\n    row,\n    col\n  } = node;\n  const neighbors = [];\n\n  if (row + 1 >= 0 && row + 1 < ROWS && col >= 0 && col < COLS && !grid[row + 1][col].isVisited && !grid[row + 1][col].isWall) {\n    neighbors.push(grid[row + 1][col]);\n  }\n\n  if (row - 1 >= 0 && row - 1 < ROWS && col >= 0 && col < COLS && !grid[row - 1][col].isWall && !grid[row - 1][col].isVisited) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row >= 0 && row < ROWS && col - 1 >= 0 && col - 1 < COLS && !grid[row][col - 1].isWall && !grid[row][col - 1].isVisited) {\n    neighbors.push(grid[row][col - 1]);\n  }\n\n  if (row >= 0 && row < ROWS && col + 1 >= 0 && col + 1 < COLS && !grid[row][col + 1].isWall && !grid[row][col + 1].isVisited) {\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n}","map":{"version":3,"sources":["E:/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["unweightedSearchAlgorithm","grid","startNode","finishNode","queue","push","length","currentNode","shift","isWall","isVisited","edges","getUnvisitedNeighbors","i","neighbor","previousNode","node","ROWS","COLS","row","col","neighbors"],"mappings":"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","sourcesContent":["\r\nexport function unweightedSearchAlgorithm(grid,startNode,finishNode) {\r\n \r\n  const queue = [];\r\n  queue.push(startNode);\r\n  while(queue.length > 0) {\r\n    let currentNode;\r\n    // if(name === 'bfs'){\r\n    //   currentNode = queue.shift();\r\n    // }\r\n    currentNode = queue.shift();\r\n   \r\n    // else{\r\n    //   currentNode = queue.pop();\r\n    // }\r\n    if(currentNode.isWall) continue;\r\n    \r\n    // if(name === 'bfs'){\r\n    //   queue.push(currentNode);\r\n    // }\r\n    queue.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode === finishNode) {\r\n      return queue;\r\n    }\r\n    let edges = getUnvisitedNeighbors(grid,currentNode);\r\n    for (let i = 0; i < edges.length; i++){\r\n      let neighbor = edges[i];\r\n      if(!neighbor.isVisited) {\r\n        neighbor.isVisited = true;\r\n        neighbor.previousNode = currentNode;\r\n        queue.push(neighbor);\r\n      }\r\n    } \r\n    // console.log('queue')\r\n    // console.log(queue.length)\r\n    //     console.log(queue)\r\n  }\r\n  return queue;\r\n}\r\n\r\n// function getUnvisitedNeighbors(node, grid, name) {\r\n//   const neighbors = [];\r\n//   const {col, row} = node;\r\n\r\n//   if (row > 0) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row - 1][col]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row - 1][col]);\r\n//     }\r\n//   }\r\n\r\n//   if (row < grid.length - 1) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row + 1][col]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row + 1][col]);\r\n//     }\r\n//   } \r\n\r\n//   if (col > 0) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row][col - 1]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row][col - 1]);\r\n//     }\r\n//   } \r\n\r\n//   if (col < grid[0].length - 1) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row][col + 1]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row][col + 1]);\r\n//     }\r\n//   }\r\n//   return neighbors.filter(neighbor => !neighbor.isVisited);\r\n// }\r\n                        \r\nfunction  getUnvisitedNeighbors(grid, node) {\r\n  const ROWS = grid.length;\r\n  const COLS = grid[0].length;\r\n\r\n  const { row, col } = node;\r\n  const neighbors = [];\r\n\r\n  if (\r\n      row + 1 >= 0 &&\r\n      row + 1 < ROWS &&\r\n      col >= 0 &&\r\n      col < COLS &&\r\n      !grid[row + 1][col].isVisited &&\r\n      !grid[row + 1][col].isWall\r\n  ) {\r\n      neighbors.push(grid[row + 1][col]);\r\n  }\r\n  if (\r\n      row - 1 >= 0 &&\r\n      row - 1 < ROWS &&\r\n      col >= 0 &&\r\n      col < COLS &&\r\n      !grid[row - 1][col].isWall &&\r\n      !grid[row - 1][col].isVisited\r\n  ) {\r\n      neighbors.push(grid[row - 1][col]);\r\n  }\r\n  if (\r\n      row >= 0 &&\r\n      row < ROWS &&\r\n      col - 1 >= 0 &&\r\n      col - 1 < COLS &&\r\n      !grid[row][col - 1].isWall &&\r\n      !grid[row][col - 1].isVisited\r\n  ) {\r\n      neighbors.push(grid[row][col - 1]);\r\n  }\r\n  if (\r\n      row >= 0 &&\r\n      row < ROWS &&\r\n      col + 1 >= 0 &&\r\n      col + 1 < COLS &&\r\n      !grid[row][col + 1].isWall &&\r\n      !grid[row][col + 1].isVisited\r\n  ) {\r\n      neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}"]},"metadata":{},"sourceType":"module"}