{"ast":null,"code":"// export function dfs(grid,startNode,finishNode) {\n//     const queue = [];\n//     const visitedNodesInOrder = [];\n//     startNode.isVisited = true;\n//     queue.push(startNode);\n//     while(queue.length > 0) {\n//       let currentNode;\n//       currentNode = queue.pop();\n//       // currentNode.isVisited = true;\n//       // if(currentNode.isWall) continue;\n//       if(currentNode.isWall) continue;\n//       if(currentNode === finishNode) {\n//         return visitedNodesInOrder;\n//       }\n//       let edges = getUnvisitedNeighbors(grid,currentNode);\n//       for (let i = 0; i < edges.length; i++){\n//         let neighbor = edges[i];\n//         if(!neighbor.isVisited) {\n//           // neighbor.isVisited = true;\n//           if(neighbor.isWall) continue;\n//           neighbor.previousNode = currentNode;\n//           visitedNodesInOrder.push(neighbor);\n//           queue.push(neighbor);    \n//         }\n//       } \n//     }\n//     return visitedNodesInOrder;\n// }\n// export function dfs(grid,startNode,finishNode) {\n//   const queue = [];\n//   const visitedNodesInOrder = [];\n//   startNode.isVisited = true;\n//   queue.push(startNode);\n//   while(!!queue.length) {\n//     let currentNode;\n//     currentNode = queue.pop();\n//   //   if(currentNode.isWall) continue;\n//   //  queue.push(currentNode);\n//     // currentNode.isVisited = true;\n//     if(currentNode === finishNode) {\n//       return queue;\n//     }\n//     if(currentNode.isWall) continue;\n//    // console.log('currentNode')\n//    // console.log(currentNode)\n//     let edges = getUnvisitedNeighbors(grid, currentNode);\n//     /////console.log('edges')\n//     ////console.log(edges)\n//     for (let i = 0; i < edges.length; i++){\n//       let neighbor = edges[i];\n//       if(!neighbor.isVisited) {\n//       neighbor.isVisited = true;\n//         if(neighbor.isWall) continue;\n//         neighbor.previousNode = currentNode;\n//         visitedNodesInOrder.push(neighbor);\n//         queue.push(neighbor);    \n//       }\n//     } \n//   }\n//   return \n// }\nexport function dfs(grid, startNode, finishNode) {\n  const stack = [];\n  const visitedNodesInOrder = [];\n  startNode.isVisited = true;\n  stack.push(startNode);\n\n  while (!!stack.length) {\n    let node = stack.pop();\n    if (finishNode === node) return visitedNodesInOrder;\n    if (node.isWall) continue;\n    const neighbors = getUnvisitedNeighbors(grid, node);\n\n    for (const neighbor of neighbors) {\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = node;\n        visitedNodesInOrder.push(neighbor);\n        stack.push(neighbor);\n      }\n    }\n  }\n\n  return visitedNodesInOrder;\n} // function getUnvisitedNeighbors(grid, node) {\n//   const ROWS = grid.length;\n//   const COLS = grid[0].length;\n//   const { row, col } = node;\n//   const neighbors = [];\n//   if (\n//     row - 1 >= 0 &&\n//     row - 1 < ROWS &&\n//     col >= 0 &&\n//     col < COLS &&\n//     !grid[row - 1][col].isWall &&\n//     !grid[row - 1][col].isVisited\n//   ) {\n//         neighbors.unshift(grid[row - 1][col]);\n//   }\n//   if (\n//     row >= 0 &&\n//     row < ROWS &&\n//     col + 1 >= 0 &&\n//     col + 1 < COLS &&\n//     !grid[row][col + 1].isWall &&\n//     !grid[row][col + 1].isVisited\n//   ) {\n//     neighbors.unshift(grid[row][col + 1]);\n//   }\n//   if (\n//       row + 1 >= 0 &&\n//       row + 1 < ROWS &&\n//       col >= 0 &&\n//       col < COLS &&\n//       !grid[row + 1][col].isVisited &&\n//       !grid[row + 1][col].isWall\n//   ) {\n//       neighbors.unshift(grid[row + 1][col]);\n//   }\n//   if (\n//       row >= 0 &&\n//       row < ROWS &&\n//       col - 1 >= 0 &&\n//       col - 1 < COLS &&\n//       !grid[row][col - 1].isWall &&\n//       !grid[row][col - 1].isVisited\n//   ) {\n//       neighbors.unshift(grid[row][col - 1]);\n//   }\n//   return neighbors;\n// }\n\nfunction getUnvisitedNeighbors(grid, node) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    //console.log(0)\n    neighbors.unshift(grid[row - 1][col]);\n  } //up\n\n\n  if (col < grid[0].length - 1) {\n    //console.log(3)\n    neighbors.unshift(grid[row][col + 1]);\n  } //right\n\n\n  if (row < grid.length - 1) {\n    // console.log(1)\n    neighbors.unshift(grid[row + 1][col]);\n  } //down \n\n\n  if (col > 0) {\n    ////console.log(2)\n    neighbors.unshift(grid[row][col - 1]);\n  } //left \n\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"sources":["E:/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/DFS.jsx"],"names":["dfs","grid","startNode","finishNode","stack","visitedNodesInOrder","isVisited","push","length","node","pop","isWall","neighbors","getUnvisitedNeighbors","neighbor","previousNode","col","row","unshift","filter"],"mappings":"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","sourcesContent":["// export function dfs(grid,startNode,finishNode) {\r\n\r\n//     const queue = [];\r\n//     const visitedNodesInOrder = [];\r\n\r\n//     startNode.isVisited = true;\r\n//     queue.push(startNode);\r\n\r\n//     while(queue.length > 0) {\r\n//       let currentNode;\r\n//       currentNode = queue.pop();\r\n//       // currentNode.isVisited = true;\r\n//       // if(currentNode.isWall) continue;\r\n      \r\n      \r\n//       if(currentNode.isWall) continue;\r\n\r\n//       if(currentNode === finishNode) {\r\n//         return visitedNodesInOrder;\r\n//       }\r\n\r\n   \r\n//       let edges = getUnvisitedNeighbors(grid,currentNode);\r\n     \r\n//       for (let i = 0; i < edges.length; i++){\r\n//         let neighbor = edges[i];\r\n//         if(!neighbor.isVisited) {\r\n//           // neighbor.isVisited = true;\r\n//           if(neighbor.isWall) continue;\r\n//           neighbor.previousNode = currentNode;\r\n//           visitedNodesInOrder.push(neighbor);\r\n//           queue.push(neighbor);    \r\n//         }\r\n//       } \r\n//     }\r\n//     return visitedNodesInOrder;\r\n// }\r\n\r\n// export function dfs(grid,startNode,finishNode) {\r\n\r\n//   const queue = [];\r\n//   const visitedNodesInOrder = [];\r\n//   startNode.isVisited = true;\r\n//   queue.push(startNode);\r\n//   while(!!queue.length) {\r\n//     let currentNode;\r\n//     currentNode = queue.pop();\r\n//   //   if(currentNode.isWall) continue;\r\n//   //  queue.push(currentNode);\r\n//     // currentNode.isVisited = true;\r\n    \r\n//     if(currentNode === finishNode) {\r\n//       return queue;\r\n//     }\r\n//     if(currentNode.isWall) continue;\r\n//    // console.log('currentNode')\r\n//    // console.log(currentNode)\r\n//     let edges = getUnvisitedNeighbors(grid, currentNode);\r\n//     /////console.log('edges')\r\n//     ////console.log(edges)\r\n//     for (let i = 0; i < edges.length; i++){\r\n//       let neighbor = edges[i];\r\n//       if(!neighbor.isVisited) {\r\n//       neighbor.isVisited = true;\r\n//         if(neighbor.isWall) continue;\r\n//         neighbor.previousNode = currentNode;\r\n//         visitedNodesInOrder.push(neighbor);\r\n//         queue.push(neighbor);    \r\n//       }\r\n//     } \r\n//   }\r\n//   return \r\n// }\r\n\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const stack = [];\r\n  const visitedNodesInOrder = [];\r\n\r\n  startNode.isVisited = true;\r\n  stack.push(startNode);\r\n\r\n  while (!!stack.length) {\r\n      let node = stack.pop();\r\n\r\n      if (finishNode === node)\r\n          return visitedNodesInOrder;\r\n\r\n      if (node.isWall) continue;\r\n\r\n      const neighbors = getUnvisitedNeighbors(grid, node);\r\n\r\n      for (const neighbor of neighbors) {\r\n        if(!neighbor.isVisited){\r\n          neighbor.isVisited = true;\r\n          neighbor.previousNode = node;\r\n          visitedNodesInOrder.push(neighbor);\r\n          stack.push(neighbor);\r\n        }\r\n      }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\n// function getUnvisitedNeighbors(grid, node) {\r\n//   const ROWS = grid.length;\r\n//   const COLS = grid[0].length;\r\n\r\n//   const { row, col } = node;\r\n//   const neighbors = [];\r\n\r\n//   if (\r\n//     row - 1 >= 0 &&\r\n//     row - 1 < ROWS &&\r\n//     col >= 0 &&\r\n//     col < COLS &&\r\n//     !grid[row - 1][col].isWall &&\r\n//     !grid[row - 1][col].isVisited\r\n//   ) {\r\n//         neighbors.unshift(grid[row - 1][col]);\r\n//   }\r\n  \r\n//   if (\r\n//     row >= 0 &&\r\n//     row < ROWS &&\r\n//     col + 1 >= 0 &&\r\n//     col + 1 < COLS &&\r\n//     !grid[row][col + 1].isWall &&\r\n//     !grid[row][col + 1].isVisited\r\n//   ) {\r\n//     neighbors.unshift(grid[row][col + 1]);\r\n//   }\r\n\r\n//   if (\r\n//       row + 1 >= 0 &&\r\n//       row + 1 < ROWS &&\r\n//       col >= 0 &&\r\n//       col < COLS &&\r\n//       !grid[row + 1][col].isVisited &&\r\n//       !grid[row + 1][col].isWall\r\n//   ) {\r\n//       neighbors.unshift(grid[row + 1][col]);\r\n//   }\r\n \r\n//   if (\r\n//       row >= 0 &&\r\n//       row < ROWS &&\r\n//       col - 1 >= 0 &&\r\n//       col - 1 < COLS &&\r\n//       !grid[row][col - 1].isWall &&\r\n//       !grid[row][col - 1].isVisited\r\n//   ) {\r\n//       neighbors.unshift(grid[row][col - 1]);\r\n//   }\r\n  \r\n\r\n//   return neighbors;\r\n// }\r\nfunction getUnvisitedNeighbors(grid, node) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n  \r\n    if (row > 0) {\r\n        //console.log(0)\r\n        neighbors.unshift(grid[row - 1][col]);\r\n    }//up\r\n    if (col < grid[0].length - 1) {\r\n        //console.log(3)\r\n        neighbors.unshift(grid[row][col + 1]);\r\n    }//right\r\n    if (row < grid.length - 1) {\r\n      // console.log(1)\r\n       neighbors.unshift(grid[row + 1][col]);\r\n    }//down \r\n    if (col > 0) {\r\n        ////console.log(2)\r\n        neighbors.unshift(grid[row][col - 1]);\r\n    }//left \r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n                          \r\n  "]},"metadata":{},"sourceType":"module"}