{"ast":null,"code":"export function getAllNodes(grid) {\n  const nodes = [];\n\n  for (var i = 0; i < grid.length; i++) {\n    for (var j = 0; j < grid[i].length; j++) {\n      nodes.push(grid[i][j]);\n    }\n  }\n\n  return nodes;\n}\nexport function getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\nexport function getUnvisitedNeighborsforAstar(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isWall);\n}\nexport function updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\nexport function updateUnvisitedNeighborsforastar(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighborsforAstar(node, grid);\n\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.previousNode = node;\n  }\n\n  return unvisitedNeighbors;\n}\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n\n  return nodesInShortestPathOrder;\n}\nexport function sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\nexport function findCost(node, finishNode) {\n  node.heruistic = getManhattan(node, finishNode);\n  node.cost = node.distance + node.heruistic;\n}\n\nfunction getManhattan(node, finishNode) {\n  return Math.abs(finishNode.col - node.col) + Math.abs(finishNode.row - node.row);\n}","map":{"version":3,"sources":["/Users/sankalpapokhrel/Documents/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/AlgoTools.jsx"],"names":["getAllNodes","grid","nodes","i","length","j","push","getUnvisitedNeighbors","node","neighbors","col","row","filter","neighbor","isVisited","getUnvisitedNeighborsforAstar","isWall","updateUnvisitedNeighbors","unvisitedNeighbors","distance","previousNode","updateUnvisitedNeighborsforastar","getNodesInShortestPathOrder","finishNode","nodesInShortestPathOrder","currentNode","unshift","sortNodesByDistance","unvisitedNodes","sort","nodeA","nodeB","findCost","heruistic","getManhattan","cost","Math","abs"],"mappings":"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","sourcesContent":["export function getAllNodes(grid) {\n  const nodes = [];\n  for (var i = 0; i < grid.length; i++) {\n    for (var j = 0; j < grid[i].length; j++) {\n      nodes.push(grid[i][j]);\n    }\n  }\n  return nodes;\n}\n\nexport function getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nexport function getUnvisitedNeighborsforAstar(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) {\n    neighbors.push(grid[row - 1][col]);\n  }\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isWall);\n}\n\nexport function updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nexport function updateUnvisitedNeighborsforastar(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighborsforAstar(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.previousNode = node;\n  }\n  return unvisitedNeighbors;\n}\n\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n\nexport function sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nexport function findCost(node, finishNode) {\n  node.heruistic = getManhattan(node, finishNode);\n  node.cost = node.distance + node.heruistic;\n}\n\nfunction getManhattan(node, finishNode) {\n  return (\n    Math.abs(finishNode.col - node.col) + Math.abs(finishNode.row - node.row)\n  );\n}\n"]},"metadata":{},"sourceType":"module"}