{"ast":null,"code":"import { getAllNodes, getUnvisitedNeighborsforAstar, sortNodesByDistance, findCost, updateUnvisitedNeighborsforastar } from \"./AlgoTools\";\n\nfunction removeFromArray(arr, elt) {\n  // Could use indexOf here instead to be more efficient\n  for (var i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] == elt) {\n      arr.splice(i, 1);\n    }\n  }\n} // An educated guess of how far it is between two points\n\n\nfunction heuristic(node, finishNode) {\n  return Math.abs(finishNode.col - node.col) + Math.abs(finishNode.row - node.row); //var d = dist(a.i, a.j, b.i, b.j);\n  // var d = abs(a.i - b.i) + abs(a.j - b.j);\n  //return d;\n} // Width and height of each cell of grid\n\n\nexport function aStar(grid, startNode, finishNode) {\n  // Open and closed set\n  var openSet = [];\n  var closedSet = []; // Start and end\n\n  var start = startNode;\n  var end = finishNode;\n  openSet.push(start); // Am I still searching?\n\n  while (openSet.length > 0) {\n    // Best next option\n    var winner = 0;\n\n    for (var i = 0; i < openSet.length; i++) {\n      if (openSet[i].f < openSet[winner].f) {\n        winner = i;\n      }\n    }\n\n    var current = openSet[winner]; // Did I finish?\n\n    if (current === end) {\n      return openSet;\n    } // Best option moves from openSet to closedSet\n\n\n    removeFromArray(openSet, current);\n    closedSet.push(current); // Check all the neighbors\n\n    var neighbors = [];\n    neighbors = getUnvisitedNeighborsforAstar(current, grid);\n\n    for (var i = 0; i < neighbors.length; i++) {\n      var neighbor = neighbors[i]; // Valid next spot?\n\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\n        var tempG = current.g + heuristic(neighbor, end); // Is this a better path than before?\n\n        var newPath = false;\n\n        if (openSet.includes(neighbor)) {\n          if (tempG < neighbor.g) {\n            neighbor.g = tempG;\n            newPath = true;\n          }\n        } else {\n          neighbor.g = tempG;\n          newPath = true;\n          openSet.push(neighbor);\n        } // Yes, it's a better path\n\n\n        if (newPath) {\n          neighbor.h = heuristic(neighbor, end);\n          neighbor.f = neighbor.g + neighbor.h;\n          neighbor.previous = current;\n        }\n      }\n    } // Uh oh, no solution\n\n  }\n\n  console.log('no solution');\n  return null;\n}","map":{"version":3,"sources":["C:/Users/Acer/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/AstarPrototype.jsx"],"names":["getAllNodes","getUnvisitedNeighborsforAstar","sortNodesByDistance","findCost","updateUnvisitedNeighborsforastar","removeFromArray","arr","elt","i","length","splice","heuristic","node","finishNode","Math","abs","col","row","aStar","grid","startNode","openSet","closedSet","start","end","push","winner","f","current","neighbors","neighbor","includes","isWall","tempG","g","newPath","h","previous","console","log"],"mappings":"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","sourcesContent":["import {getAllNodes,getUnvisitedNeighborsforAstar,sortNodesByDistance,findCost,updateUnvisitedNeighborsforastar } from \"./AlgoTools\";\r\n\r\nfunction removeFromArray(arr, elt) {\r\n  // Could use indexOf here instead to be more efficient\r\n  for (var i = arr.length - 1; i >= 0; i--) {\r\n    if (arr[i] == elt) {\r\n      arr.splice(i, 1);\r\n    }\r\n  }\r\n}\r\n\r\n// An educated guess of how far it is between two points\r\nfunction heuristic(node, finishNode) {\r\n    return(Math.abs(finishNode.col-node.col)+Math.abs(finishNode.row-node.row))\r\n    //var d = dist(a.i, a.j, b.i, b.j);\r\n  // var d = abs(a.i - b.i) + abs(a.j - b.j);\r\n  //return d;\r\n}\r\n// Width and height of each cell of grid\r\n\r\nexport function aStar(grid, startNode, finishNode){\r\n    // Open and closed set\r\n    var openSet = [];\r\n    var closedSet = [];\r\n\r\n    // Start and end\r\n    var start=startNode;\r\n    var end=finishNode;\r\n  openSet.push(start) \r\n  // Am I still searching?\r\n  while (openSet.length > 0) {\r\n    // Best next option\r\n    var winner = 0;\r\n    for (var i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[winner].f) {\r\n        winner = i;\r\n      }\r\n    }\r\n    var current = openSet[winner];\r\n\r\n    // Did I finish?\r\n    if (current === end) {\r\n     return(openSet)\r\n      \r\n    }\r\n\r\n    // Best option moves from openSet to closedSet\r\n    removeFromArray(openSet, current);\r\n    closedSet.push(current);\r\n\r\n    // Check all the neighbors\r\n    var neighbors =[];\r\n    neighbors= getUnvisitedNeighborsforAstar(current,grid)\r\n    for (var i = 0; i < neighbors.length; i++) {\r\n      var neighbor = neighbors[i];\r\n\r\n      // Valid next spot?\r\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\r\n        var tempG = current.g + heuristic(neighbor, end);\r\n\r\n        // Is this a better path than before?\r\n        var newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        // Yes, it's a better path\r\n        if (newPath) {\r\n          neighbor.h = heuristic(neighbor, end);\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n    // Uh oh, no solution\r\n  } \r\n\r\n    console.log('no solution');\r\n    return null;\r\n}    \r\n  \r\n\r\n  \r\n\r\n \r\n\r\n \r\n"]},"metadata":{},"sourceType":"module"}