{"ast":null,"code":"export function unweightedSearchAlgorithm(grid, startNode, finishNode, name) {\n  console.log(name);\n  const queue = [];\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    let currentNode; // if(name === 'bfs'){\n    //   currentNode = queue.shift();\n    // }\n\n    currentNode = queue.shift();\n    console.log('currentNode');\n    console.log(currentNode); // else{\n    //   currentNode = queue.pop();\n    // }\n\n    if (currentNode.isWall) continue; // if(name === 'bfs'){\n    //   queue.push(currentNode);\n    // }\n\n    queue.push(currentNode);\n    currentNode.isVisited = true;\n\n    if (currentNode === finishNode) {\n      return queue;\n    }\n\n    let edges = getUnvisitedNeighbors(currentNode, grid, name);\n    console.log('edges');\n    console.log(edges);\n\n    for (let i = 0; i < edges.length; i++) {\n      let neighbor = edges[i];\n\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    } // console.log('queue')\n    // console.log(queue.length)\n    //     console.log(queue)\n\n  }\n\n  return queue;\n}\n\nfunction getUnvisitedNeighbors(node, grid, name) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row - 1][col]);\n    } else {\n      neighbors.unshift(grid[row - 1][col]);\n    }\n  }\n\n  if (col < grid[0].length - 1) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row][col + 1]);\n    } else {\n      neighbors.unshift(grid[row][col + 1]);\n    }\n  }\n\n  if (row < grid.length - 1) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row + 1][col]);\n    } else {\n      neighbors.unshift(grid[row + 1][col]);\n    }\n  }\n\n  if (col > 0) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row][col - 1]);\n    } else {\n      neighbors.unshift(grid[row][col - 1]);\n    }\n  } // if (col < grid[0].length - 1) {\n  //   if (name === \"bfs\") {\n  //     neighbors.push(grid[row][col + 1]);\n  //   } else {\n  //     neighbors.unshift(grid[row][col + 1]);\n  //   }\n  // }\n\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"sources":["E:/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["unweightedSearchAlgorithm","grid","startNode","finishNode","name","console","log","queue","push","length","currentNode","shift","isWall","isVisited","edges","getUnvisitedNeighbors","i","neighbor","previousNode","node","neighbors","col","row","unshift","filter"],"mappings":"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","sourcesContent":["\r\nexport function unweightedSearchAlgorithm(grid,startNode,finishNode,name) {\r\n  console.log(name);\r\n  const queue = [];\r\n  queue.push(startNode);\r\n  while(queue.length > 0) {\r\n    let currentNode;\r\n    // if(name === 'bfs'){\r\n    //   currentNode = queue.shift();\r\n    // }\r\n    currentNode = queue.shift();\r\n    console.log('currentNode')\r\n    \r\n    console.log(currentNode)\r\n    // else{\r\n    //   currentNode = queue.pop();\r\n    // }\r\n    if(currentNode.isWall) continue;\r\n    \r\n    // if(name === 'bfs'){\r\n    //   queue.push(currentNode);\r\n    // }\r\n    queue.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode === finishNode) {\r\n      return queue;\r\n    }\r\n    let edges = getUnvisitedNeighbors(currentNode, grid, name);\r\n    console.log('edges')\r\n    console.log(edges)\r\n    for (let i = 0; i < edges.length; i++){\r\n      let neighbor = edges[i];\r\n      if(!neighbor.isVisited) {\r\n        neighbor.isVisited = true;\r\n        neighbor.previousNode = currentNode;\r\n        queue.push(neighbor);\r\n        \r\n      }\r\n    } \r\n    // console.log('queue')\r\n    // console.log(queue.length)\r\n    //     console.log(queue)\r\n  }\r\n  return queue;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid, name) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n\r\n  if (row > 0) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row - 1][col]);\r\n    } else {\r\n      neighbors.unshift(grid[row - 1][col]);\r\n    }\r\n  }\r\n\r\n  if (col < grid[0].length - 1) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row][col + 1]);\r\n    } else {\r\n      neighbors.unshift(grid[row][col + 1]);\r\n    }\r\n  }\r\n\r\n  if (row < grid.length - 1) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row + 1][col]);\r\n    } else {\r\n      neighbors.unshift(grid[row + 1][col]);\r\n    }\r\n  } \r\n\r\n  if (col > 0) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row][col - 1]);\r\n    } else {\r\n      neighbors.unshift(grid[row][col - 1]);\r\n    }\r\n  } \r\n\r\n  // if (col < grid[0].length - 1) {\r\n  //   if (name === \"bfs\") {\r\n  //     neighbors.push(grid[row][col + 1]);\r\n  //   } else {\r\n  //     neighbors.unshift(grid[row][col + 1]);\r\n  //   }\r\n  // }\r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n                        \r\n"]},"metadata":{},"sourceType":"module"}