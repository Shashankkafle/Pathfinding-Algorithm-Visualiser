{"ast":null,"code":"function removeFromArray(arr, elt) {\n  // Could use indexOf here instead to be more efficient\n  for (var i = arr.length - 1; i >= 0; i--) {\n    if (arr[i] == elt) {\n      arr.splice(i, 1);\n    }\n  }\n} // An educated guess of how far it is between two points\n\n\nfunction heuristic(a, b) {\n  return Math.abs(finishNode.col - node.col) + Math.abs(finishNode.row - node.row); //var d = dist(a.i, a.j, b.i, b.j);\n  // var d = abs(a.i - b.i) + abs(a.j - b.j);\n  //return d;\n} // Width and height of each cell of grid\n\n\nexport function aStar(grid, startNode, finishNode) {\n  // Open and closed set\n  var openSet = [];\n  var closedSet = []; // Start and end\n\n  var start = startNode;\n  var end = finishNode;\n  closedSet.push(startNode); // Am I still searching?\n\n  while (openSet.length > 0) {\n    // Best next option\n    var winner = 0;\n\n    for (var i = 0; i < openSet.length; i++) {\n      if (openSet[i].f < openSet[winner].f) {\n        winner = i;\n      }\n    }\n\n    var current = openSet[winner]; // Did I finish?\n\n    if (current === end) {\n      return openSet;\n    } // Best option moves from openSet to closedSet\n\n\n    removeFromArray(openSet, current);\n    closedSet.push(current); // Check all the neighbors\n\n    var neighbors = current.neighbors;\n\n    for (var i = 0; i < neighbors.length; i++) {\n      var neighbor = neighbors[i]; // Valid next spot?\n\n      if (!closedSet.includes(neighbor) && !neighbor.wall) {\n        var tempG = current.g + heuristic(neighbor, end); // Is this a better path than before?\n\n        var newPath = false;\n\n        if (openSet.includes(neighbor)) {\n          if (tempG < neighbor.g) {\n            neighbor.g = tempG;\n            newPath = true;\n          }\n        } else {\n          neighbor.g = tempG;\n          newPath = true;\n          openSet.push(neighbor);\n        } // Yes, it's a better path\n\n\n        if (newPath) {\n          neighbor.h = heuristic(neighbor, end);\n          neighbor.f = neighbor.g + neighbor.h;\n          neighbor.previous = current;\n        }\n      }\n    } // Uh oh, no solution\n\n  }\n\n  console.log('no solution');\n  return null;\n}","map":{"version":3,"sources":["C:/Users/Acer/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/AstarPrototype.jsx"],"names":["removeFromArray","arr","elt","i","length","splice","heuristic","a","b","Math","abs","finishNode","col","node","row","aStar","grid","startNode","openSet","closedSet","start","end","push","winner","f","current","neighbors","neighbor","includes","wall","tempG","g","newPath","h","previous","console","log"],"mappings":"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","sourcesContent":["function removeFromArray(arr, elt) {\r\n  // Could use indexOf here instead to be more efficient\r\n  for (var i = arr.length - 1; i >= 0; i--) {\r\n    if (arr[i] == elt) {\r\n      arr.splice(i, 1);\r\n    }\r\n  }\r\n}\r\n\r\n// An educated guess of how far it is between two points\r\nfunction heuristic(a, b) {\r\n    return(Math.abs(finishNode.col-node.col)+Math.abs(finishNode.row-node.row))\r\n    //var d = dist(a.i, a.j, b.i, b.j);\r\n  // var d = abs(a.i - b.i) + abs(a.j - b.j);\r\n  //return d;\r\n}\r\n// Width and height of each cell of grid\r\n\r\nexport function aStar(grid, startNode, finishNode){\r\n    // Open and closed set\r\n    var openSet = [];\r\n    var closedSet = [];\r\n\r\n    // Start and end\r\n    var start=startNode;\r\n    var end=finishNode;\r\n    closedSet.push(startNode) \r\n  // Am I still searching?\r\n  while (openSet.length > 0) {\r\n    // Best next option\r\n    var winner = 0;\r\n    for (var i = 0; i < openSet.length; i++) {\r\n      if (openSet[i].f < openSet[winner].f) {\r\n        winner = i;\r\n      }\r\n    }\r\n    var current = openSet[winner];\r\n\r\n    // Did I finish?\r\n    if (current === end) {\r\n     return(openSet)\r\n      \r\n    }\r\n\r\n    // Best option moves from openSet to closedSet\r\n    removeFromArray(openSet, current);\r\n    closedSet.push(current);\r\n\r\n    // Check all the neighbors\r\n    var neighbors = current.neighbors;\r\n    for (var i = 0; i < neighbors.length; i++) {\r\n      var neighbor = neighbors[i];\r\n\r\n      // Valid next spot?\r\n      if (!closedSet.includes(neighbor) && !neighbor.wall) {\r\n        var tempG = current.g + heuristic(neighbor, end);\r\n\r\n        // Is this a better path than before?\r\n        var newPath = false;\r\n        if (openSet.includes(neighbor)) {\r\n          if (tempG < neighbor.g) {\r\n            neighbor.g = tempG;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          neighbor.g = tempG;\r\n          newPath = true;\r\n          openSet.push(neighbor);\r\n        }\r\n\r\n        // Yes, it's a better path\r\n        if (newPath) {\r\n          neighbor.h = heuristic(neighbor, end);\r\n          neighbor.f = neighbor.g + neighbor.h;\r\n          neighbor.previous = current;\r\n        }\r\n      }\r\n    }\r\n    // Uh oh, no solution\r\n  } \r\n\r\n    console.log('no solution');\r\n    return null;\r\n}    \r\n  \r\n\r\n  \r\n\r\n \r\n\r\n \r\n"]},"metadata":{},"sourceType":"module"}