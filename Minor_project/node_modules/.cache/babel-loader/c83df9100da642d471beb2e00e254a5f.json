{"ast":null,"code":"// export function unweightedSearchAlgorithm(grid,startNode,finishNode) {\n//   const queue = [];\n//   queue.push(startNode);\n//   while(queue.length > 0) {\n//     let currentNode;\n//     // if(name === 'bfs'){\n//     //   currentNode = queue.shift();\n//     // }\n//     currentNode = queue.shift();\n//     // else{\n//     //   currentNode = queue.pop();\n//     // }\n//     if(currentNode.isWall) continue;\n//     // if(name === 'bfs'){\n//     //   queue.push(currentNode);\n//     // }\n//     queue.push(currentNode);\n//     currentNode.isVisited = true;\n//     if(currentNode === finishNode) {\n//       return queue;\n//     }\n//     let edges = getUnvisitedNeighbors(grid,currentNode);\n//     for (let i = 0; i < edges.length; i++){\n//       let neighbor = edges[i];\n//       if(!neighbor.isVisited) {\n//         neighbor.isVisited = true;\n//         neighbor.previousNode = currentNode;\n//         queue.push(neighbor);\n//       }\n//     } \n//     // console.log('queue')\n//     // console.log(queue.length)\n//     //     console.log(queue)\n//   }\n//   return queue;\n// }\n// function getUnvisitedNeighbors(node, grid, name) {\n//   const neighbors = [];\n//   const {col, row} = node;\n//   if (row > 0) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row - 1][col]);\n//     } else {\n//       neighbors.unshift(grid[row - 1][col]);\n//     }\n//   }\n//   if (row < grid.length - 1) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row + 1][col]);\n//     } else {\n//       neighbors.unshift(grid[row + 1][col]);\n//     }\n//   } \n//   if (col > 0) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row][col - 1]);\n//     } else {\n//       neighbors.unshift(grid[row][col - 1]);\n//     }\n//   } \n//   if (col < grid[0].length - 1) {\n//     if (name === \"bfs\") {\n//       neighbors.push(grid[row][col + 1]);\n//     } else {\n//       neighbors.unshift(grid[row][col + 1]);\n//     }\n//   }\n//   return neighbors.filter(neighbor => !neighbor.isVisited);\n// }\nexport function dfs(grid, startNode, finishNode) {\n  const stack = [];\n  const visitedNodesInOrder = [];\n  startNode.isVisited = true;\n  stack.push(startNode);\n\n  while (!!stack.length) {\n    let node = stack.pop();\n    if (finishNode === node) return visitedNodesInOrder;\n    if (node.isWall) continue;\n    const neighbors = getAllNeighbors(grid, node);\n\n    for (const neighbor of neighbors) {\n      neighbor.isVisited = true;\n      neighbor.previousNode = node;\n      visitedNodesInOrder.push(neighbor);\n      stack.push(neighbor);\n    }\n  }\n\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbors(grid, node) {\n  const ROWS = grid.length;\n  const COLS = grid[0].length;\n  const {\n    row,\n    col\n  } = node;\n  const neighbors = [];\n\n  if (row + 1 >= 0 && row + 1 < ROWS && col >= 0 && col < COLS && !grid[row + 1][col].isVisited && !grid[row + 1][col].isWall) {\n    neighbors.push(grid[row + 1][col]);\n  }\n\n  if (row - 1 >= 0 && row - 1 < ROWS && col >= 0 && col < COLS && !grid[row - 1][col].isWall && !grid[row - 1][col].isVisited) {\n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row >= 0 && row < ROWS && col - 1 >= 0 && col - 1 < COLS && !grid[row][col - 1].isWall && !grid[row][col - 1].isVisited) {\n    neighbors.push(grid[row][col - 1]);\n  }\n\n  if (row >= 0 && row < ROWS && col + 1 >= 0 && col + 1 < COLS && !grid[row][col + 1].isWall && !grid[row][col + 1].isVisited) {\n    neighbors.push(grid[row][col + 1]);\n  }\n\n  return neighbors;\n}","map":{"version":3,"sources":["E:/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["dfs","grid","startNode","finishNode","stack","visitedNodesInOrder","isVisited","push","length","node","pop","isWall","neighbors","getAllNeighbors","neighbor","previousNode","getUnvisitedNeighbors","ROWS","COLS","row","col"],"mappings":"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","sourcesContent":["\r\n// export function unweightedSearchAlgorithm(grid,startNode,finishNode) {\r\n \r\n//   const queue = [];\r\n//   queue.push(startNode);\r\n//   while(queue.length > 0) {\r\n//     let currentNode;\r\n//     // if(name === 'bfs'){\r\n//     //   currentNode = queue.shift();\r\n//     // }\r\n//     currentNode = queue.shift();\r\n   \r\n//     // else{\r\n//     //   currentNode = queue.pop();\r\n//     // }\r\n//     if(currentNode.isWall) continue;\r\n    \r\n//     // if(name === 'bfs'){\r\n//     //   queue.push(currentNode);\r\n//     // }\r\n//     queue.push(currentNode);\r\n//     currentNode.isVisited = true;\r\n//     if(currentNode === finishNode) {\r\n//       return queue;\r\n//     }\r\n//     let edges = getUnvisitedNeighbors(grid,currentNode);\r\n//     for (let i = 0; i < edges.length; i++){\r\n//       let neighbor = edges[i];\r\n//       if(!neighbor.isVisited) {\r\n//         neighbor.isVisited = true;\r\n//         neighbor.previousNode = currentNode;\r\n//         queue.push(neighbor);\r\n//       }\r\n//     } \r\n//     // console.log('queue')\r\n//     // console.log(queue.length)\r\n//     //     console.log(queue)\r\n//   }\r\n//   return queue;\r\n// }\r\n\r\n// function getUnvisitedNeighbors(node, grid, name) {\r\n//   const neighbors = [];\r\n//   const {col, row} = node;\r\n\r\n//   if (row > 0) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row - 1][col]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row - 1][col]);\r\n//     }\r\n//   }\r\n\r\n//   if (row < grid.length - 1) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row + 1][col]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row + 1][col]);\r\n//     }\r\n//   } \r\n\r\n//   if (col > 0) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row][col - 1]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row][col - 1]);\r\n//     }\r\n//   } \r\n\r\n//   if (col < grid[0].length - 1) {\r\n//     if (name === \"bfs\") {\r\n//       neighbors.push(grid[row][col + 1]);\r\n//     } else {\r\n//       neighbors.unshift(grid[row][col + 1]);\r\n//     }\r\n//   }\r\n//   return neighbors.filter(neighbor => !neighbor.isVisited);\r\n// }\r\n             \r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const stack = [];\r\n  const visitedNodesInOrder = [];\r\n\r\n  startNode.isVisited = true;\r\n  stack.push(startNode);\r\n\r\n  while (!!stack.length) {\r\n      let node = stack.pop();\r\n\r\n      if (finishNode === node)\r\n          return visitedNodesInOrder;\r\n\r\n      if (node.isWall) continue;\r\n\r\n      const neighbors = getAllNeighbors(grid, node);\r\n\r\n      for (const neighbor of neighbors) {\r\n          neighbor.isVisited = true;\r\n          neighbor.previousNode = node;\r\n          visitedNodesInOrder.push(neighbor);\r\n          stack.push(neighbor);\r\n      }\r\n  }\r\n\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction  getUnvisitedNeighbors(grid, node) {\r\n  const ROWS = grid.length;\r\n  const COLS = grid[0].length;\r\n\r\n  const { row, col } = node;\r\n  const neighbors = [];\r\n\r\n  if (\r\n      row + 1 >= 0 &&\r\n      row + 1 < ROWS &&\r\n      col >= 0 &&\r\n      col < COLS &&\r\n      !grid[row + 1][col].isVisited &&\r\n      !grid[row + 1][col].isWall\r\n  ) {\r\n      neighbors.push(grid[row + 1][col]);\r\n  }\r\n  if (\r\n      row - 1 >= 0 &&\r\n      row - 1 < ROWS &&\r\n      col >= 0 &&\r\n      col < COLS &&\r\n      !grid[row - 1][col].isWall &&\r\n      !grid[row - 1][col].isVisited\r\n  ) {\r\n      neighbors.push(grid[row - 1][col]);\r\n  }\r\n  if (\r\n      row >= 0 &&\r\n      row < ROWS &&\r\n      col - 1 >= 0 &&\r\n      col - 1 < COLS &&\r\n      !grid[row][col - 1].isWall &&\r\n      !grid[row][col - 1].isVisited\r\n  ) {\r\n      neighbors.push(grid[row][col - 1]);\r\n  }\r\n  if (\r\n      row >= 0 &&\r\n      row < ROWS &&\r\n      col + 1 >= 0 &&\r\n      col + 1 < COLS &&\r\n      !grid[row][col + 1].isWall &&\r\n      !grid[row][col + 1].isVisited\r\n  ) {\r\n      neighbors.push(grid[row][col + 1]);\r\n  }\r\n\r\n  return neighbors;\r\n}"]},"metadata":{},"sourceType":"module"}