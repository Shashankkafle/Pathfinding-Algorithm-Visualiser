{"ast":null,"code":"export function dfs(grid, startNode, finishNode) {\n  const queue = [];\n  const visitedNodesInOrder = [];\n  startNode.isVisited = true;\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    let currentNode;\n    currentNode = queue.pop(); // currentNode.isVisited = true;\n    // if(currentNode.isWall) continue;\n\n    if (currentNode === finishNode) {\n      return queue;\n    }\n\n    if (currentNode.isWall) continue; // console.log('currentNode')\n    // console.log(currentNode)\n\n    let edges = getUnvisitedNeighbors(grid, currentNode); /////console.log('edges')\n    ////console.log(edges)\n\n    for (let i = 0; i < edges.length; i++) {\n      let neighbor = edges[i];\n\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        if (neighbor.isWall) continue;\n        neighbor.previousNode = currentNode;\n        visitedNodesInOrder.push(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return queue;\n} // export function dfs(grid, startNode, finishNode) {\n//   const stack = [];\n//   const visitedNodesInOrder = [];\n//   startNode.isVisited = true;\n//   stack.push(startNode);\n//   while (!!stack.length) {\n//       let node = stack.pop();\n//       if (finishNode === node)\n//           return visitedNodesInOrder;\n//       if (node.isWall) continue;\n//       const neighbors = getUnvisitedNeighbors(grid, node);\n//       for (const neighbor of neighbors) {\n//           neighbor.isVisited = true;\n//           neighbor.previousNode = node;\n//           visitedNodesInOrder.push(neighbor);\n//           stack.push(neighbor);\n//       }\n//   }\n//   return visitedNodesInOrder;\n// }\n\nfunction getUnvisitedNeighbors(grid, node) {\n  const ROWS = grid.length;\n  const COLS = grid[0].length;\n  const {\n    row,\n    col\n  } = node;\n  const neighbors = [];\n\n  if (row - 1 >= 0 && row - 1 < ROWS && col >= 0 && col < COLS && !grid[row - 1][col].isWall && !grid[row - 1][col].isVisited) {\n    neighbors.unshift(grid[row - 1][col]);\n  }\n\n  if (row >= 0 && row < ROWS && col + 1 >= 0 && col + 1 < COLS && !grid[row][col + 1].isWall && !grid[row][col + 1].isVisited) {\n    neighbors.unshift(grid[row][col + 1]);\n  }\n\n  if (row + 1 >= 0 && row + 1 < ROWS && col >= 0 && col < COLS && !grid[row + 1][col].isVisited && !grid[row + 1][col].isWall) {\n    neighbors.unshift(grid[row + 1][col]);\n  }\n\n  if (row >= 0 && row < ROWS && col - 1 >= 0 && col - 1 < COLS && !grid[row][col - 1].isWall && !grid[row][col - 1].isVisited) {\n    neighbors.unshift(grid[row][col - 1]);\n  }\n\n  return neighbors;\n} // function getUnvisitedNeighbors(node, grid) {\n//     const neighbors = [];\n//     const {col, row} = node;\n//     if (row > 0) {\n//         //console.log(0)\n//         neighbors.unshift(grid[row - 1][col]);\n//     }//up\n//     if (col < grid[0].length - 1) {\n//         //console.log(3)\n//         neighbors.unshift(grid[row][col + 1]);\n//     }//right\n//     if (row < grid.length - 1) {\n//       // console.log(1)\n//        neighbors.unshift(grid[row + 1][col]);\n//     }//down \n//     if (col > 0) {\n//         ////console.log(2)\n//         neighbors.unshift(grid[row][col - 1]);\n//     }//left \n//     return neighbors.filter(neighbor => !neighbor.isVisited);\n// }","map":{"version":3,"sources":["E:/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/DFS.jsx"],"names":["dfs","grid","startNode","finishNode","queue","visitedNodesInOrder","isVisited","push","length","currentNode","pop","isWall","edges","getUnvisitedNeighbors","i","neighbor","previousNode","node","ROWS","COLS","row","col","neighbors","unshift"],"mappings":"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","sourcesContent":["export function dfs(grid,startNode,finishNode) {\r\n\r\n    const queue = [];\r\n    const visitedNodesInOrder = [];\r\n\r\n    startNode.isVisited = true;\r\n    queue.push(startNode);\r\n    while(queue.length > 0) {\r\n      let currentNode;\r\n      currentNode = queue.pop();\r\n      // currentNode.isVisited = true;\r\n      // if(currentNode.isWall) continue;\r\n      \r\n      if(currentNode === finishNode) {\r\n        return queue;\r\n      }\r\n\r\n      if(currentNode.isWall) continue;\r\n     // console.log('currentNode')\r\n     // console.log(currentNode)\r\n      let edges = getUnvisitedNeighbors(grid,currentNode);\r\n      /////console.log('edges')\r\n      ////console.log(edges)\r\n      for (let i = 0; i < edges.length; i++){\r\n        let neighbor = edges[i];\r\n        if(!neighbor.isVisited) {\r\n          neighbor.isVisited = true;\r\n          if(neighbor.isWall) continue;\r\n          neighbor.previousNode = currentNode;\r\n          visitedNodesInOrder.push(neighbor);\r\n          queue.push(neighbor);    \r\n        }\r\n      } \r\n    }\r\n    return queue;\r\n}\r\n\r\n// export function dfs(grid, startNode, finishNode) {\r\n//   const stack = [];\r\n//   const visitedNodesInOrder = [];\r\n\r\n//   startNode.isVisited = true;\r\n//   stack.push(startNode);\r\n\r\n//   while (!!stack.length) {\r\n//       let node = stack.pop();\r\n\r\n//       if (finishNode === node)\r\n//           return visitedNodesInOrder;\r\n\r\n//       if (node.isWall) continue;\r\n\r\n//       const neighbors = getUnvisitedNeighbors(grid, node);\r\n\r\n//       for (const neighbor of neighbors) {\r\n//           neighbor.isVisited = true;\r\n//           neighbor.previousNode = node;\r\n//           visitedNodesInOrder.push(neighbor);\r\n//           stack.push(neighbor);\r\n//       }\r\n//   }\r\n\r\n//   return visitedNodesInOrder;\r\n// }\r\n\r\nfunction getUnvisitedNeighbors(grid, node) {\r\n  const ROWS = grid.length;\r\n  const COLS = grid[0].length;\r\n\r\n  const { row, col } = node;\r\n  const neighbors = [];\r\n\r\n  if (\r\n    row - 1 >= 0 &&\r\n    row - 1 < ROWS &&\r\n    col >= 0 &&\r\n    col < COLS &&\r\n    !grid[row - 1][col].isWall &&\r\n    !grid[row - 1][col].isVisited\r\n  ) {\r\n        neighbors.unshift(grid[row - 1][col]);\r\n  }\r\n  \r\n  if (\r\n    row >= 0 &&\r\n    row < ROWS &&\r\n    col + 1 >= 0 &&\r\n    col + 1 < COLS &&\r\n    !grid[row][col + 1].isWall &&\r\n    !grid[row][col + 1].isVisited\r\n  ) {\r\n    neighbors.unshift(grid[row][col + 1]);\r\n  }\r\n\r\n  if (\r\n      row + 1 >= 0 &&\r\n      row + 1 < ROWS &&\r\n      col >= 0 &&\r\n      col < COLS &&\r\n      !grid[row + 1][col].isVisited &&\r\n      !grid[row + 1][col].isWall\r\n  ) {\r\n      neighbors.unshift(grid[row + 1][col]);\r\n  }\r\n \r\n  if (\r\n      row >= 0 &&\r\n      row < ROWS &&\r\n      col - 1 >= 0 &&\r\n      col - 1 < COLS &&\r\n      !grid[row][col - 1].isWall &&\r\n      !grid[row][col - 1].isVisited\r\n  ) {\r\n      neighbors.unshift(grid[row][col - 1]);\r\n  }\r\n  \r\n\r\n  return neighbors;\r\n}\r\n// function getUnvisitedNeighbors(node, grid) {\r\n//     const neighbors = [];\r\n//     const {col, row} = node;\r\n  \r\n//     if (row > 0) {\r\n//         //console.log(0)\r\n//         neighbors.unshift(grid[row - 1][col]);\r\n//     }//up\r\n//     if (col < grid[0].length - 1) {\r\n//         //console.log(3)\r\n//         neighbors.unshift(grid[row][col + 1]);\r\n//     }//right\r\n//     if (row < grid.length - 1) {\r\n//       // console.log(1)\r\n//        neighbors.unshift(grid[row + 1][col]);\r\n//     }//down \r\n//     if (col > 0) {\r\n//         ////console.log(2)\r\n//         neighbors.unshift(grid[row][col - 1]);\r\n//     }//left \r\n//     return neighbors.filter(neighbor => !neighbor.isVisited);\r\n// }\r\n                          \r\n  "]},"metadata":{},"sourceType":"module"}