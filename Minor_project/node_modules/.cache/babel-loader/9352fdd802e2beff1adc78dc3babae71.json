{"ast":null,"code":"export function dfs(grid, startNode, finishNode) {\n  const queue = [];\n  queue.push(startNode);\n\n  while (queue.length > 0) {\n    let currentNode;\n    currentNode = queue.pop();\n    if (currentNode.isWall) continue; //  queue.push(currentNode);\n\n    currentNode.isVisited = true;\n\n    if (currentNode === finishNode) {\n      return queue;\n    } // console.log('currentNode')\n    // console.log(currentNode)\n\n\n    let edges = getUnvisitedNeighbors(currentNode, grid); /////console.log('edges')\n    ////console.log(edges)\n\n    for (let i = 0; i < edges.length; i++) {\n      let neighbor = edges[i];\n\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    }\n  }\n\n  return queue;\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    //console.log(0)\n    neighbors.unshift(grid[row - 1][col]);\n  } //up\n\n\n  if (col < grid[0].length - 1) {\n    //console.log(3)\n    neighbors.unshift(grid[row][col + 1]);\n  } //right\n\n\n  if (row < grid.length - 1) {\n    // console.log(1)\n    neighbors.unshift(grid[row + 1][col]);\n  } //down \n\n\n  if (col > 0) {\n    ////console.log(2)\n    neighbors.unshift(grid[row][col - 1]);\n  } //left \n\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"sources":["E:/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/DFS.jsx"],"names":["dfs","grid","startNode","finishNode","queue","push","length","currentNode","pop","isWall","isVisited","edges","getUnvisitedNeighbors","i","neighbor","previousNode","node","neighbors","col","row","unshift","filter"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAkBC,SAAlB,EAA4BC,UAA5B,EAAwC;AAE3C,QAAMC,KAAK,GAAG,EAAd;AACAA,EAAAA,KAAK,CAACC,IAAN,CAAWH,SAAX;;AACA,SAAME,KAAK,CAACE,MAAN,GAAe,CAArB,EAAwB;AACtB,QAAIC,WAAJ;AACAA,IAAAA,WAAW,GAAGH,KAAK,CAACI,GAAN,EAAd;AACA,QAAGD,WAAW,CAACE,MAAf,EAAuB,SAHD,CAIxB;;AACEF,IAAAA,WAAW,CAACG,SAAZ,GAAwB,IAAxB;;AACA,QAAGH,WAAW,KAAKJ,UAAnB,EAA+B;AAC7B,aAAOC,KAAP;AACD,KARqB,CASvB;AACA;;;AACC,QAAIO,KAAK,GAAGC,qBAAqB,CAACL,WAAD,EAAcN,IAAd,CAAjC,CAXsB,CAYtB;AACA;;AACA,SAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACL,MAA1B,EAAkCO,CAAC,EAAnC,EAAsC;AACpC,UAAIC,QAAQ,GAAGH,KAAK,CAACE,CAAD,CAApB;;AACA,UAAG,CAACC,QAAQ,CAACJ,SAAb,EAAwB;AACtBI,QAAAA,QAAQ,CAACJ,SAAT,GAAqB,IAArB;AACAI,QAAAA,QAAQ,CAACC,YAAT,GAAwBR,WAAxB;AACAH,QAAAA,KAAK,CAACC,IAAN,CAAWS,QAAX;AACD;AACF;AACF;;AACD,SAAOV,KAAP;AACD;;AAED,SAASQ,qBAAT,CAA+BI,IAA/B,EAAqCf,IAArC,EAA2C;AACzC,QAAMgB,SAAS,GAAG,EAAlB;AACA,QAAM;AAACC,IAAAA,GAAD;AAAMC,IAAAA;AAAN,MAAaH,IAAnB;;AAEA,MAAIG,GAAG,GAAG,CAAV,EAAa;AACT;AACAF,IAAAA,SAAS,CAACG,OAAV,CAAkBnB,IAAI,CAACkB,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAlB;AACH,GAPwC,CAOxC;;;AACD,MAAIA,GAAG,GAAGjB,IAAI,CAAC,CAAD,CAAJ,CAAQK,MAAR,GAAiB,CAA3B,EAA8B;AAC1B;AACAW,IAAAA,SAAS,CAACG,OAAV,CAAkBnB,IAAI,CAACkB,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAlB;AACH,GAXwC,CAWxC;;;AACD,MAAIC,GAAG,GAAGlB,IAAI,CAACK,MAAL,GAAc,CAAxB,EAA2B;AACzB;AACCW,IAAAA,SAAS,CAACG,OAAV,CAAkBnB,IAAI,CAACkB,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAlB;AACF,GAfwC,CAexC;;;AACD,MAAIA,GAAG,GAAG,CAAV,EAAa;AACT;AACAD,IAAAA,SAAS,CAACG,OAAV,CAAkBnB,IAAI,CAACkB,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAlB;AACH,GAnBwC,CAmBxC;;;AACD,SAAOD,SAAS,CAACI,MAAV,CAAiBP,QAAQ,IAAI,CAACA,QAAQ,CAACJ,SAAvC,CAAP;AACD","sourcesContent":["export function dfs(grid,startNode,finishNode) {\r\n   \r\n    const queue = [];\r\n    queue.push(startNode);\r\n    while(queue.length > 0) {\r\n      let currentNode;\r\n      currentNode = queue.pop();\r\n      if(currentNode.isWall) continue;\r\n    //  queue.push(currentNode);\r\n      currentNode.isVisited = true;\r\n      if(currentNode === finishNode) {\r\n        return queue;\r\n      }\r\n     // console.log('currentNode')\r\n     // console.log(currentNode)\r\n      let edges = getUnvisitedNeighbors(currentNode, grid);\r\n      /////console.log('edges')\r\n      ////console.log(edges)\r\n      for (let i = 0; i < edges.length; i++){\r\n        let neighbor = edges[i];\r\n        if(!neighbor.isVisited) {\r\n          neighbor.isVisited = true;\r\n          neighbor.previousNode = currentNode;\r\n          queue.push(neighbor);    \r\n        }\r\n      } \r\n    }\r\n    return queue;\r\n  }\r\n  \r\n  function getUnvisitedNeighbors(node, grid) {\r\n    const neighbors = [];\r\n    const {col, row} = node;\r\n  \r\n    if (row > 0) {\r\n        //console.log(0)\r\n        neighbors.unshift(grid[row - 1][col]);\r\n    }//up\r\n    if (col < grid[0].length - 1) {\r\n        //console.log(3)\r\n        neighbors.unshift(grid[row][col + 1]);\r\n    }//right\r\n    if (row < grid.length - 1) {\r\n      // console.log(1)\r\n       neighbors.unshift(grid[row + 1][col]);\r\n    }//down \r\n    if (col > 0) {\r\n        ////console.log(2)\r\n        neighbors.unshift(grid[row][col - 1]);\r\n    }//left \r\n    return neighbors.filter(neighbor => !neighbor.isVisited);\r\n  }\r\n                          \r\n  "]},"metadata":{},"sourceType":"module"}