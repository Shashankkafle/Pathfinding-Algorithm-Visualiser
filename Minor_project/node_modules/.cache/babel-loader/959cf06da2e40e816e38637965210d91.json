{"ast":null,"code":"export function bfs(grid, startNode) {\n  let nodesLen = {};\n\n  for (let i = 0; i < grid.length; i++) {\n    nodesLen[i] = Infinity;\n  }\n\n  nodesLen[startNode] = 0;\n  let queue = [startNode];\n  let current; // This loop will keep traversing nodes in the queue until we have no other node to traverse\n\n  while (queue.length != 0) {\n    current = queue.shift(); // Removes the first element in the array\n\n    let curConnected = grid[current]; // We get all the nodes connected to the current node\n\n    let neighborIdx = [];\n    let idx = curConnected.indexOf(startNode); // Gets the index of the first node connected to the current node because the number one in our array shows that the node is connected to anothe node on that index\n    // If there is no node at the index of one, the index variable will be set to -1. \n\n    while (idx != -1) {\n      neighborIdx.push(idx); // So while index does not equals to -1, push our index onto our list of neighbors.\n\n      idx = curConnected.indexOf(1, idx + 1); // This line searches for the next connected node.\n    } // Now that we know all the nodes connected to the current node, we loop through this connected nodes, and get the distance\n\n\n    for (let j = 0; j < neighborIdx.length; j++) {\n      if (nodesLen[neighborIdx[j]] == Infinity) {\n        // This line we haven't set the distance from the nodesLen[neighborIdx[j]] yet so we will set now. \n        nodesLen[neighborIdx[j]] = nodesLen[current] + 1;\n        queue.push(neighborIdx[j]); // We push the neighbor to the queue so the next time we go through the while loop, we will check the neighbors of that node too.\n      }\n    }\n  }\n\n  return nodesLen;\n} // let exBFSGraph = [grid]\n// bfs(exBFSGraph, startNode)","map":{"version":3,"sources":["E:/minor project/Pathfinding-Algorithm-visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["bfs","grid","startNode","nodesLen","i","length","Infinity","queue","current","shift","curConnected","neighborIdx","idx","indexOf","push","j"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8B;AACnC,MAAIC,QAAQ,GAAG,EAAf;;AAEA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGH,IAAI,CAACI,MAAxB,EAAgCD,CAAC,EAAjC,EAAoC;AAClCD,IAAAA,QAAQ,CAACC,CAAD,CAAR,GAAcE,QAAd;AACD;;AACDH,EAAAA,QAAQ,CAACD,SAAD,CAAR,GAAsB,CAAtB;AAEA,MAAIK,KAAK,GAAG,CAACL,SAAD,CAAZ;AACA,MAAIM,OAAJ,CATmC,CAWnC;;AACA,SAAMD,KAAK,CAACF,MAAN,IAAgB,CAAtB,EAAwB;AACtBG,IAAAA,OAAO,GAAID,KAAK,CAACE,KAAN,EAAX,CADsB,CACG;;AAEzB,QAAIC,YAAY,GAAGT,IAAI,CAACO,OAAD,CAAvB,CAHsB,CAGW;;AACjC,QAAIG,WAAW,GAAG,EAAlB;AACA,QAAIC,GAAG,GAAGF,YAAY,CAACG,OAAb,CAAqBX,SAArB,CAAV,CALsB,CAKoB;AAE1C;;AACA,WAAMU,GAAG,IAAI,CAAC,CAAd,EAAgB;AACdD,MAAAA,WAAW,CAACG,IAAZ,CAAiBF,GAAjB,EADc,CACQ;;AACtBA,MAAAA,GAAG,GAAGF,YAAY,CAACG,OAAb,CAAqB,CAArB,EAAwBD,GAAG,GAAG,CAA9B,CAAN,CAFc,CAEyB;AACxC,KAXqB,CAatB;;;AACA,SAAM,IAAIG,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,WAAW,CAACN,MAAjC,EAAyCU,CAAC,EAA1C,EAA6C;AAC3C,UAAIZ,QAAQ,CAACQ,WAAW,CAACI,CAAD,CAAZ,CAAR,IAA4BT,QAAhC,EAAyC;AAAE;AACzCH,QAAAA,QAAQ,CAACQ,WAAW,CAACI,CAAD,CAAZ,CAAR,GAA2BZ,QAAQ,CAACK,OAAD,CAAR,GAAoB,CAA/C;AACAD,QAAAA,KAAK,CAACO,IAAN,CAAWH,WAAW,CAACI,CAAD,CAAtB,EAFuC,CAEZ;AAC5B;AACF;AACF;;AAED,SAAOZ,QAAP;AACD,C,CAED;AAEA","sourcesContent":["export function bfs(grid, startNode) {\r\n  let nodesLen = {};\r\n\r\n  for(let i = 0; i < grid.length; i++){\r\n    nodesLen[i] = Infinity; \r\n  }\r\n  nodesLen[startNode] = 0;\r\n\r\n  let queue = [startNode]\r\n  let current; \r\n\r\n  // This loop will keep traversing nodes in the queue until we have no other node to traverse\r\n  while(queue.length != 0){\r\n    current  = queue.shift() // Removes the first element in the array\r\n\r\n    let curConnected = grid[current] // We get all the nodes connected to the current node\r\n    let neighborIdx = []\r\n    let idx = curConnected.indexOf(startNode) // Gets the index of the first node connected to the current node because the number one in our array shows that the node is connected to anothe node on that index\r\n\r\n    // If there is no node at the index of one, the index variable will be set to -1. \r\n    while(idx != -1){\r\n      neighborIdx.push(idx) // So while index does not equals to -1, push our index onto our list of neighbors.\r\n      idx = curConnected.indexOf(1, idx + 1) // This line searches for the next connected node.\r\n    }\r\n\r\n    // Now that we know all the nodes connected to the current node, we loop through this connected nodes, and get the distance\r\n    for ( let j = 0; j < neighborIdx.length; j++){\r\n      if (nodesLen[neighborIdx[j]] == Infinity){ // This line we haven't set the distance from the nodesLen[neighborIdx[j]] yet so we will set now. \r\n        nodesLen[neighborIdx[j]] = nodesLen[current] + 1\r\n        queue.push(neighborIdx[j]) // We push the neighbor to the queue so the next time we go through the while loop, we will check the neighbors of that node too.\r\n      }\r\n    }\r\n  }\r\n\r\n  return nodesLen\r\n}\r\n\r\n// let exBFSGraph = [grid]\r\n\r\n// bfs(exBFSGraph, startNode)"]},"metadata":{},"sourceType":"module"}