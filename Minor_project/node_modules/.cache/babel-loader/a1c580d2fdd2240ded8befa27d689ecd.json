{"ast":null,"code":"import { updateUnvisitedNeighbors, getUnvisitedNeighbors } from './AlgoTools'; // export function bfs(grid,startNode,finishNode) {\n//   const queue = [];\n//   startNode.isVisited = true;\n//   queue.push(startNode);\n//   const unvisitedNodes = getAllNodes(grid);\n//   while(queue.length > 0) {\n//     let currentNode = queue.shift();\n//     queue.push(currentNode);\n//     currentNode.isVisited = true;\n//     if(currentNode == finishNode) {\n//       return queue;\n//     }\n//     sortNodesByDistance(unvisitedNodes);\n//     let edges = unvisitedNodes.shift();\n//     for (let i = 0; i < edges.length; i++){\n//       let neighbor = edges[i];\n//       if(!neighbor.isVisited) {\n//         neighbor.isVisited = true;\n//         neighbor.previousNode = current;\n//         queue.push(neighbor);\n//       }\n//     }\n//     updateUnvisitedNeighbors(edges, grid);\n//   }\n// }\n\nexport function unweightedSearchAlgorithm(grid, startNode, finishNode, queue, boardArray, name) {\n  if (!startNode || !finishNode || startNode === finishNode) {\n    return false;\n  }\n\n  let structure = startNode;\n  let exploredNodes = {\n    startNode: true\n  };\n\n  while (structure.length) {\n    let currentNode = name === \"bfs\" ? structure.shift() : structure.pop();\n    nodesToAnimate.push(currentNode);\n    if (name === \"dfs\") exploredNodes[currentNode.id] = true;\n    currentNode.isVisited = true;\n\n    if (currentNode.id === finishNode) {\n      return queue;\n    }\n\n    let currentNeighbors = getUnvisitedNeighbors(currentNode.id, grid);\n    currentNeighbors.forEach(neighbor => {\n      if (!exploredNodes[neighbor]) {\n        if (name === \"bfs\") exploredNodes[neighbor] = true;\n        currentNode.previousNode = currentNode.id;\n        structure.push(nodes[neighbor]);\n      }\n    });\n  }\n\n  return false;\n}\n\nfunction getNeighbors(id, nodes, boardArray, name) {\n  let coordinates = id.split(\"-\");\n  let x = parseInt(coordinates[0]);\n  let y = parseInt(coordinates[1]);\n  let neighbors = [];\n  let potentialNeighbor;\n\n  if (boardArray[x - 1] && boardArray[x - 1][y]) {\n    potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`;\n\n    if (nodes[potentialNeighbor].status !== \"wall\") {\n      if (name === \"bfs\") {\n        neighbors.push(potentialNeighbor);\n      } else {\n        neighbors.unshift(potentialNeighbor);\n      }\n    }\n  }\n\n  if (boardArray[x][y + 1]) {\n    potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`;\n\n    if (nodes[potentialNeighbor].status !== \"wall\") {\n      if (name === \"bfs\") {\n        neighbors.push(potentialNeighbor);\n      } else {\n        neighbors.unshift(potentialNeighbor);\n      }\n    }\n  }\n\n  if (boardArray[x + 1] && boardArray[x + 1][y]) {\n    potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`;\n\n    if (nodes[potentialNeighbor].status !== \"wall\") {\n      if (name === \"bfs\") {\n        neighbors.push(potentialNeighbor);\n      } else {\n        neighbors.unshift(potentialNeighbor);\n      }\n    }\n  }\n\n  if (boardArray[x][y - 1]) {\n    potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`;\n\n    if (nodes[potentialNeighbor].status !== \"wall\") {\n      if (name === \"bfs\") {\n        neighbors.push(potentialNeighbor);\n      } else {\n        neighbors.unshift(potentialNeighbor);\n      }\n    }\n  }\n\n  return neighbors;\n}","map":{"version":3,"sources":["E:/minor project/Pathfinding-Algorithm-visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["updateUnvisitedNeighbors","getUnvisitedNeighbors","unweightedSearchAlgorithm","grid","startNode","finishNode","queue","boardArray","name","structure","exploredNodes","length","currentNode","shift","pop","nodesToAnimate","push","id","isVisited","currentNeighbors","forEach","neighbor","previousNode","nodes","getNeighbors","coordinates","split","x","parseInt","y","neighbors","potentialNeighbor","toString","status","unshift"],"mappings":"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","sourcesContent":["import {updateUnvisitedNeighbors,getUnvisitedNeighbors} from './AlgoTools';\r\n\r\n// export function bfs(grid,startNode,finishNode) {\r\n\r\n//   const queue = [];\r\n//   startNode.isVisited = true;\r\n//   queue.push(startNode);\r\n//   const unvisitedNodes = getAllNodes(grid);\r\n\r\n//   while(queue.length > 0) {\r\n//     let currentNode = queue.shift();\r\n//     queue.push(currentNode);\r\n//     currentNode.isVisited = true;\r\n//     if(currentNode == finishNode) {\r\n//       return queue;\r\n//     }\r\n//     sortNodesByDistance(unvisitedNodes);\r\n//     let edges = unvisitedNodes.shift();\r\n//     for (let i = 0; i < edges.length; i++){\r\n//       let neighbor = edges[i];\r\n//       if(!neighbor.isVisited) {\r\n//         neighbor.isVisited = true;\r\n//         neighbor.previousNode = current;\r\n//         queue.push(neighbor);\r\n//       }\r\n//     }\r\n//     updateUnvisitedNeighbors(edges, grid);\r\n//   }\r\n// }\r\n\r\nexport function unweightedSearchAlgorithm(grid, startNode, finishNode, queue, boardArray, name) {\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    return false;\r\n  }\r\n  let structure = startNode;\r\n  let exploredNodes = {startNode: true};\r\n  while (structure.length) {\r\n    let currentNode = name === \"bfs\" ? structure.shift() : structure.pop();\r\n    nodesToAnimate.push(currentNode);\r\n    if (name === \"dfs\") exploredNodes[currentNode.id] = true;\r\n    currentNode.isVisited = true;\r\n    if (currentNode.id === finishNode) {\r\n      return queue;\r\n    }\r\n    let currentNeighbors = getUnvisitedNeighbors(currentNode.id, grid);\r\n    currentNeighbors.forEach(neighbor => {\r\n      if (!exploredNodes[neighbor]) {\r\n        if (name === \"bfs\") exploredNodes[neighbor] = true;\r\n        currentNode.previousNode = currentNode.id;\r\n        structure.push(nodes[neighbor]);\r\n      }\r\n    });\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction getNeighbors(id, nodes, boardArray, name) {\r\n  let coordinates = id.split(\"-\");\r\n  let x = parseInt(coordinates[0]);\r\n  let y = parseInt(coordinates[1]);\r\n  let neighbors = [];\r\n  let potentialNeighbor;\r\n  if (boardArray[x - 1] && boardArray[x - 1][y]) {\r\n    potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`\r\n    if (nodes[potentialNeighbor].status !== \"wall\") {\r\n      if (name === \"bfs\") {\r\n        neighbors.push(potentialNeighbor);\r\n      } else {\r\n        neighbors.unshift(potentialNeighbor);\r\n      }\r\n    }\r\n  }\r\n  if (boardArray[x][y + 1]) {\r\n    potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`\r\n    if (nodes[potentialNeighbor].status !== \"wall\") {\r\n      if (name === \"bfs\") {\r\n        neighbors.push(potentialNeighbor);\r\n      } else {\r\n        neighbors.unshift(potentialNeighbor);\r\n      }\r\n    }\r\n  }\r\n  if (boardArray[x + 1] && boardArray[x + 1][y]) {\r\n    potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`\r\n    if (nodes[potentialNeighbor].status !== \"wall\") {\r\n      if (name === \"bfs\") {\r\n        neighbors.push(potentialNeighbor);\r\n      } else {\r\n        neighbors.unshift(potentialNeighbor);\r\n      }\r\n    }\r\n  }\r\n  if (boardArray[x][y - 1]) {\r\n    potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`\r\n    if (nodes[potentialNeighbor].status !== \"wall\") {\r\n      if (name === \"bfs\") {\r\n        neighbors.push(potentialNeighbor);\r\n      } else {\r\n        neighbors.unshift(potentialNeighbor);\r\n      }\r\n    }\r\n  }\r\n  return neighbors;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}