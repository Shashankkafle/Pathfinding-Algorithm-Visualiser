{"ast":null,"code":"export function bfs(startNode) {\n  // Create a Queue and add our initial node in it\n  let q = new Queue(this.startNode.length);\n  let explored = new Set();\n  q.enqueue(node); // Mark the first node as explored explored.\n\n  add(node); // We'll continue till our queue gets empty\n\n  while (!q.isEmpty()) {\n    let t = q.dequeue(); // Log every element that comes out of the Queue\n\n    console.log(t); // 1. In the edges object, we search for nodes this node is directly connected to.\n    // 2. We filter out the nodes that have already been explored.\n    // 3. Then we mark each unexplored node as explored and add it to the queue.\n\n    this.edges[t].filter(n => !explored.has(n)).forEach(n => {\n      explored.add(n);\n      q.enqueue(n);\n    });\n  }\n}","map":{"version":3,"sources":["E:/minor project/Pathfinding-Algorithm-visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["bfs","startNode","q","Queue","length","explored","Set","enqueue","node","add","isEmpty","t","dequeue","console","log","edges","filter","n","has","forEach"],"mappings":"AAAA,OAAO,SAASA,GAAT,CAAaC,SAAb,EAAwB;AAC7B;AACA,MAAIC,CAAC,GAAG,IAAIC,KAAJ,CAAU,KAAKF,SAAL,CAAeG,MAAzB,CAAR;AACA,MAAIC,QAAQ,GAAG,IAAIC,GAAJ,EAAf;AACAJ,EAAAA,CAAC,CAACK,OAAF,CAAUC,IAAV,EAJ6B,CAM7B;;AACAC,EAAAA,GAAG,CAACD,IAAD,CAAH,CAP6B,CAS7B;;AACA,SAAO,CAACN,CAAC,CAACQ,OAAF,EAAR,EAAqB;AAClB,QAAIC,CAAC,GAAGT,CAAC,CAACU,OAAF,EAAR,CADkB,CAGlB;;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYH,CAAZ,EAJkB,CAMlB;AACA;AACA;;AACA,SAAKI,KAAL,CAAWJ,CAAX,EACCK,MADD,CACQC,CAAC,IAAI,CAACZ,QAAQ,CAACa,GAAT,CAAaD,CAAb,CADd,EAECE,OAFD,CAESF,CAAC,IAAI;AACXZ,MAAAA,QAAQ,CAACI,GAAT,CAAaQ,CAAb;AACAf,MAAAA,CAAC,CAACK,OAAF,CAAUU,CAAV;AACF,KALD;AAMF;AACF","sourcesContent":["export function bfs(startNode) {\r\n  // Create a Queue and add our initial node in it\r\n  let q = new Queue(this.startNode.length);\r\n  let explored = new Set();\r\n  q.enqueue(node);\r\n\r\n  // Mark the first node as explored explored.\r\n  add(node);\r\n\r\n  // We'll continue till our queue gets empty\r\n  while (!q.isEmpty()) {\r\n     let t = q.dequeue();\r\n\r\n     // Log every element that comes out of the Queue\r\n     console.log(t);\r\n\r\n     // 1. In the edges object, we search for nodes this node is directly connected to.\r\n     // 2. We filter out the nodes that have already been explored.\r\n     // 3. Then we mark each unexplored node as explored and add it to the queue.\r\n     this.edges[t]\r\n     .filter(n => !explored.has(n))\r\n     .forEach(n => {\r\n        explored.add(n);\r\n        q.enqueue(n);\r\n     });\r\n  }\r\n}"]},"metadata":{},"sourceType":"module"}