{"ast":null,"code":"import { getAllNodes, sortNodesByDistance } from './AlgoTools';\nexport function unweightedSearchAlgorithm(grid, startNode, finishNode, name) {\n  console.log(name);\n  const queue = []; // startNode.isVisited = true;\n\n  queue.push(startNode);\n  const unvisitedNodes = getAllNodes(grid);\n\n  while (queue.length > 0) {\n    sortNodesByDistance(queue);\n    let currentNode = queue.shift();\n    if (currentNode.isWall) continue;\n    queue.push(currentNode);\n    currentNode.isVisited = true;\n\n    if (currentNode == finishNode) {\n      return queue;\n    } // let edges = getUnvisitedNeighbors(currentNode, grid);\n\n\n    let edges = unvisitedNodes.shift();\n\n    for (let i = 0; i < edges.length; i++) {\n      let neighbor = edges[i];\n\n      if (!neighbor.isVisited) {\n        neighbor.isVisited = true;\n        neighbor.previousNode = currentNode;\n        queue.push(neighbor);\n      }\n    }\n  } // return queue;\n\n} // export function unweightedSearchAlgorithm(grid, startNode, finishNode, name) {\n//   console.log('bfs was touched')\n//   const visitedNodesInOrder = [];\n//   let structure = [startNode];\n//   let exploredNodes = {startNode: true};\n//   console.log(visitedNodesInOrder);\n//   while (structure.length) {\n//     let currentNode = name === \"bfs\" ? structure.shift() : structure.pop();\n//     visitedNodesInOrder.push(currentNode);\n//     if (name === \"dfs\") exploredNodes[currentNode.id]= true;\n//     currentNode.isVisited = true;\n//     if (currentNode === finishNode) {\n//       return visitedNodesInOrder;\n//     }\n//     let currentNeighbors = getUnvisitedNeighbors(currentNode, grid, name);\n//     // currentNeighbors.forEach(neighbor => {\n//     //   if (!exploredNodes[neighbor]) {\n//     //     if (name === \"bfs\") exploredNodes[neighbor] = true;\n//     //     neighbor.previousNode = currentNode.id;\n//     //     structure.push(neighbor);\n//     //   }\n//     // });\n//     for (let i=0;i<currentNeighbors.length;i++) {\n//       if (!exploredNodes[currentNeighbors[i]]) {\n//         if (name === \"bfs\") exploredNodes[currentNeighbors[i]] = true;\n//         currentNeighbors[i].previousNode = currentNode.id;\n//         structure.push(currentNeighbors[i]);\n//       }\n//     }  \n//   }\n//   return visitedNodesInOrder;\n// }\n\nfunction getUnvisitedNeighbors(node, grid, name) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row - 1][col]);\n    } else {\n      neighbors.unshift(grid[row - 1][col]);\n    }\n  }\n\n  if (row < grid.length - 1) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row + 1][col]);\n    } else {\n      neighbors.unshift(grid[row + 1][col]);\n    }\n  }\n\n  if (col > 0) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row][col - 1]);\n    } else {\n      neighbors.unshift(grid[row][col - 1]);\n    }\n  }\n\n  if (col < grid[0].length - 1) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row][col + 1]);\n    } else {\n      neighbors.unshift(grid[row][col + 1]);\n    }\n  }\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}","map":{"version":3,"sources":["E:/minor project/Pathfinding-Algorithm-visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["getAllNodes","sortNodesByDistance","unweightedSearchAlgorithm","grid","startNode","finishNode","name","console","log","queue","push","unvisitedNodes","length","currentNode","shift","isWall","isVisited","edges","i","neighbor","previousNode","getUnvisitedNeighbors","node","neighbors","col","row","unshift","filter"],"mappings":"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","sourcesContent":["import {getAllNodes, sortNodesByDistance} from './AlgoTools';\r\n\r\nexport function unweightedSearchAlgorithm(grid,startNode,finishNode,name) {\r\n  console.log(name);\r\n  const queue = [];\r\n  // startNode.isVisited = true;\r\n  queue.push(startNode);\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while(queue.length > 0) {\r\n    sortNodesByDistance(queue);\r\n    let currentNode = queue.shift();\r\n    if(currentNode.isWall) continue;\r\n    queue.push(currentNode);\r\n    currentNode.isVisited = true;\r\n    if(currentNode == finishNode) {\r\n      return queue;\r\n    }\r\n    // let edges = getUnvisitedNeighbors(currentNode, grid);\r\n\r\n    let edges = unvisitedNodes.shift();\r\n    for (let i = 0; i < edges.length; i++){\r\n      let neighbor = edges[i];\r\n      if(!neighbor.isVisited) {\r\n        neighbor.isVisited = true;\r\n        neighbor.previousNode = currentNode;\r\n        queue.push(neighbor);\r\n      }\r\n    } \r\n  }\r\n  // return queue;\r\n}\r\n\r\n// export function unweightedSearchAlgorithm(grid, startNode, finishNode, name) {\r\n//   console.log('bfs was touched')\r\n//   const visitedNodesInOrder = [];\r\n//   let structure = [startNode];\r\n  \r\n//   let exploredNodes = {startNode: true};\r\n//   console.log(visitedNodesInOrder);\r\n//   while (structure.length) {\r\n//     let currentNode = name === \"bfs\" ? structure.shift() : structure.pop();\r\n//     visitedNodesInOrder.push(currentNode);\r\n//     if (name === \"dfs\") exploredNodes[currentNode.id]= true;\r\n//     currentNode.isVisited = true;\r\n//     if (currentNode === finishNode) {\r\n//       return visitedNodesInOrder;\r\n//     }\r\n//     let currentNeighbors = getUnvisitedNeighbors(currentNode, grid, name);\r\n//     // currentNeighbors.forEach(neighbor => {\r\n//     //   if (!exploredNodes[neighbor]) {\r\n//     //     if (name === \"bfs\") exploredNodes[neighbor] = true;\r\n//     //     neighbor.previousNode = currentNode.id;\r\n//     //     structure.push(neighbor);\r\n//     //   }\r\n//     // });\r\n\r\n//     for (let i=0;i<currentNeighbors.length;i++) {\r\n//       if (!exploredNodes[currentNeighbors[i]]) {\r\n//         if (name === \"bfs\") exploredNodes[currentNeighbors[i]] = true;\r\n//         currentNeighbors[i].previousNode = currentNode.id;\r\n//         structure.push(currentNeighbors[i]);\r\n//       }\r\n//     }  \r\n//   }\r\n//   return visitedNodesInOrder;\r\n// }\r\n\r\nfunction getUnvisitedNeighbors(node, grid, name) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n\r\n  if (row > 0) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row - 1][col]);\r\n    } else {\r\n      neighbors.unshift(grid[row - 1][col]);\r\n    }\r\n  }\r\n\r\n  if (row < grid.length - 1) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row + 1][col]);\r\n    } else {\r\n      neighbors.unshift(grid[row + 1][col]);\r\n    }\r\n  } \r\n\r\n  if (col > 0) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row][col - 1]);\r\n    } else {\r\n      neighbors.unshift(grid[row][col - 1]);\r\n    }\r\n  } \r\n  if (col < grid[0].length - 1) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row][col + 1]);\r\n    } else {\r\n      neighbors.unshift(grid[row][col + 1]);\r\n    }\r\n  } \r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}