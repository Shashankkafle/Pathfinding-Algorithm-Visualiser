{"ast":null,"code":"import { getUnvisitedNeighborsforAstar, findCost } from \"./AlgoTools\";\nexport function aStar(grid, startNode, finishNode) {\n  startNode.distance = 0;\n  startNode.cost = 0;\n  var unvisitedNodes = [];\n  var visitedNodes = [];\n  unvisitedNodes.push(startNode);\n\n  while (unvisitedNodes.length > 0) {\n    var cheapestIndex = 0,\n        cheapestNode = unvisitedNodes[0];\n\n    for (var i = 0; i < unvisitedNodes.length; i++) {\n      if (unvisitedNodes[i].cost < cheapestNode.cost) {\n        cheapestIndex = i;\n      }\n    }\n\n    cheapestNode = unvisitedNodes[cheapestIndex];\n\n    if (cheapestNode.isFinish) {\n      visitedNodes.push(finishNode);\n      return visitedNodes;\n    }\n\n    unvisitedNodes.splice(cheapestIndex, 1);\n    visitedNodes.push(cheapestNode);\n    var unvisitedNeighbours = getUnvisitedNeighborsforAstar(cheapestNode, grid);\n\n    for (var i = 0; i < unvisitedNeighbours.length; i++) {\n      if (!visitedNodes.includes(unvisitedNeighbours[i])) {\n        var tempdist = cheapestNode.distance + 1;\n        var newPath = false;\n\n        if (unvisitedNodes.includes(unvisitedNeighbours[i])) {\n          if (tempdist < unvisitedNeighbours[i].distance) {\n            unvisitedNeighbours[i].distance = tempdist;\n            newPath = true;\n          }\n        } else {\n          unvisitedNeighbours[i].distance = tempdist;\n          newPath = true;\n          unvisitedNodes.push(unvisitedNeighbours[i]);\n        }\n\n        if (newPath) {\n          findCost(unvisitedNeighbours[i], finishNode);\n          unvisitedNeighbours[i].previousNode = cheapestNode;\n        }\n\n        findCost(unvisitedNeighbours[i], finishNode);\n      }\n    }\n  }\n\n  return visitedNodes;\n}","map":{"version":3,"sources":["W:/Pathfinding-Algorithm-Visualiser/Minor_project/src/Algorithms/Astar.jsx"],"names":["getUnvisitedNeighborsforAstar","findCost","aStar","grid","startNode","finishNode","distance","cost","unvisitedNodes","visitedNodes","push","length","cheapestIndex","cheapestNode","i","isFinish","splice","unvisitedNeighbours","includes","tempdist","newPath","previousNode"],"mappings":"AAAA,SAASA,6BAAT,EAAwCC,QAAxC,QAAwD,aAAxD;AAEA,OAAO,SAASC,KAAT,CAAeC,IAAf,EAAqBC,SAArB,EAAgCC,UAAhC,EAA4C;AACjDD,EAAAA,SAAS,CAACE,QAAV,GAAqB,CAArB;AACAF,EAAAA,SAAS,CAACG,IAAV,GAAiB,CAAjB;AACA,MAAIC,cAAc,GAAG,EAArB;AACA,MAAIC,YAAY,GAAG,EAAnB;AACAD,EAAAA,cAAc,CAACE,IAAf,CAAoBN,SAApB;;AACA,SAAOI,cAAc,CAACG,MAAf,GAAwB,CAA/B,EAAkC;AAChC,QAAIC,aAAa,GAAG,CAApB;AAAA,QACEC,YAAY,GAAGL,cAAc,CAAC,CAAD,CAD/B;;AAEA,SAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,cAAc,CAACG,MAAnC,EAA2CG,CAAC,EAA5C,EAAgD;AAC9C,UAAIN,cAAc,CAACM,CAAD,CAAd,CAAkBP,IAAlB,GAAyBM,YAAY,CAACN,IAA1C,EAAgD;AAC9CK,QAAAA,aAAa,GAAGE,CAAhB;AACD;AACF;;AACDD,IAAAA,YAAY,GAAGL,cAAc,CAACI,aAAD,CAA7B;;AACA,QAAIC,YAAY,CAACE,QAAjB,EAA2B;AACzBN,MAAAA,YAAY,CAACC,IAAb,CAAkBL,UAAlB;AACA,aAAOI,YAAP;AACD;;AACDD,IAAAA,cAAc,CAACQ,MAAf,CAAsBJ,aAAtB,EAAqC,CAArC;AACAH,IAAAA,YAAY,CAACC,IAAb,CAAkBG,YAAlB;AACA,QAAII,mBAAmB,GAAGjB,6BAA6B,CAACa,YAAD,EAAeV,IAAf,CAAvD;;AAEA,SAAK,IAAIW,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,mBAAmB,CAACN,MAAxC,EAAgDG,CAAC,EAAjD,EAAqD;AACnD,UAAI,CAACL,YAAY,CAACS,QAAb,CAAsBD,mBAAmB,CAACH,CAAD,CAAzC,CAAL,EAAoD;AAClD,YAAIK,QAAQ,GAAGN,YAAY,CAACP,QAAb,GAAwB,CAAvC;AACA,YAAIc,OAAO,GAAG,KAAd;;AACA,YAAIZ,cAAc,CAACU,QAAf,CAAwBD,mBAAmB,CAACH,CAAD,CAA3C,CAAJ,EAAqD;AACnD,cAAIK,QAAQ,GAAGF,mBAAmB,CAACH,CAAD,CAAnB,CAAuBR,QAAtC,EAAgD;AAC9CW,YAAAA,mBAAmB,CAACH,CAAD,CAAnB,CAAuBR,QAAvB,GAAkCa,QAAlC;AACAC,YAAAA,OAAO,GAAG,IAAV;AACD;AACF,SALD,MAKO;AACLH,UAAAA,mBAAmB,CAACH,CAAD,CAAnB,CAAuBR,QAAvB,GAAkCa,QAAlC;AACAC,UAAAA,OAAO,GAAG,IAAV;AACAZ,UAAAA,cAAc,CAACE,IAAf,CAAoBO,mBAAmB,CAACH,CAAD,CAAvC;AACD;;AACD,YAAIM,OAAJ,EAAa;AACXnB,UAAAA,QAAQ,CAACgB,mBAAmB,CAACH,CAAD,CAApB,EAAyBT,UAAzB,CAAR;AACAY,UAAAA,mBAAmB,CAACH,CAAD,CAAnB,CAAuBO,YAAvB,GAAsCR,YAAtC;AACD;;AACDZ,QAAAA,QAAQ,CAACgB,mBAAmB,CAACH,CAAD,CAApB,EAAyBT,UAAzB,CAAR;AACD;AACF;AACF;;AAED,SAAOI,YAAP;AACD","sourcesContent":["import { getUnvisitedNeighborsforAstar, findCost } from \"./AlgoTools\";\r\n\r\nexport function aStar(grid, startNode, finishNode) {\r\n  startNode.distance = 0;\r\n  startNode.cost = 0;\r\n  var unvisitedNodes = [];\r\n  var visitedNodes = [];\r\n  unvisitedNodes.push(startNode);\r\n  while (unvisitedNodes.length > 0) {\r\n    var cheapestIndex = 0,\r\n      cheapestNode = unvisitedNodes[0];\r\n    for (var i = 0; i < unvisitedNodes.length; i++) {\r\n      if (unvisitedNodes[i].cost < cheapestNode.cost) {\r\n        cheapestIndex = i;\r\n      }\r\n    }\r\n    cheapestNode = unvisitedNodes[cheapestIndex];\r\n    if (cheapestNode.isFinish) {\r\n      visitedNodes.push(finishNode);\r\n      return visitedNodes;\r\n    }\r\n    unvisitedNodes.splice(cheapestIndex, 1);\r\n    visitedNodes.push(cheapestNode);\r\n    var unvisitedNeighbours = getUnvisitedNeighborsforAstar(cheapestNode, grid);\r\n\r\n    for (var i = 0; i < unvisitedNeighbours.length; i++) {\r\n      if (!visitedNodes.includes(unvisitedNeighbours[i])) {\r\n        var tempdist = cheapestNode.distance + 1;\r\n        var newPath = false;\r\n        if (unvisitedNodes.includes(unvisitedNeighbours[i])) {\r\n          if (tempdist < unvisitedNeighbours[i].distance) {\r\n            unvisitedNeighbours[i].distance = tempdist;\r\n            newPath = true;\r\n          }\r\n        } else {\r\n          unvisitedNeighbours[i].distance = tempdist;\r\n          newPath = true;\r\n          unvisitedNodes.push(unvisitedNeighbours[i]);\r\n        }\r\n        if (newPath) {\r\n          findCost(unvisitedNeighbours[i], finishNode);\r\n          unvisitedNeighbours[i].previousNode = cheapestNode;\r\n        }\r\n        findCost(unvisitedNeighbours[i], finishNode);\r\n      }\r\n    }\r\n  }\r\n\r\n  return visitedNodes;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}