{"ast":null,"code":"// import {getAllNodes} from './AlgoTools';\n// export function bfs(grid,startNode,finishNode) {\n//   const queue = [];\n//   startNode.isVisited = true;\n//   queue.push(startNode);\n//   const unvisitedNodes = getAllNodes(grid);\n//   while(queue.length > 0) {\n//     let currentNode = queue.shift();\n//     queue.push(currentNode);\n//     currentNode.isVisited = true;\n//     if(currentNode == finishNode) {\n//       return queue;\n//     }\n//     sortNodesByDistance(unvisitedNodes);\n//     let edges = unvisitedNodes.shift();\n//     for (let i = 0; i < edges.length; i++){\n//       let neighbor = edges[i];\n//       if(!neighbor.isVisited) {\n//         neighbor.isVisited = true;\n//         neighbor.previousNode = current;\n//         queue.push(neighbor);\n//       }\n//     }\n//     updateUnvisitedNeighbors(edges, grid);\n//   }\n// }\nexport function unweightedSearchAlgorithm(grid, startNode, finishNode, name) {\n  const visitedNodesInOrder = [];\n  let structure = [startNode];\n  let exploredNodes = {\n    startNode: true\n  };\n\n  while (structure.length) {\n    let currentNode = name === \"bfs\" ? structure.shift() : structure.pop();\n    visitedNodesInOrder.push(currentNode);\n    if (name === \"dfs\") exploredNodes[currentNode] = true;\n    currentNode.isVisited = true;\n\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    let currentNeighbors = getUnvisitedNeighbors(currentNode, grid, name);\n    currentNeighbors.forEach(neighbor => {\n      if (!exploredNodes[neighbor]) {\n        if (name === \"bfs\") exploredNodes[neighbor] = true;\n        neighbor.previousNode = currentNode;\n        structure.push(neighbor);\n      }\n    });\n  }\n\n  return visitedNodesInOrder;\n}\n\nfunction getUnvisitedNeighbors(node, grid, name) {\n  const neighbors = [];\n  const {\n    col,\n    row\n  } = node;\n\n  if (row > 0) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row - 1][col]);\n    } else {\n      neighbors.unshift(grid[row - 1][col]);\n    }\n  }\n\n  if (row < grid.length - 1) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row + 1][col]);\n    } else {\n      neighbors.unshift(grid[row + 1][col]);\n    }\n  }\n\n  if (col > 0) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row][col - 1]);\n    } else {\n      neighbors.unshift(grid[row][col - 1]);\n    }\n  }\n\n  if (col < grid[0].length - 1) {\n    if (name === \"bfs\") {\n      neighbors.push(grid[row][col + 1]);\n    } else {\n      neighbors.unshift(grid[row][col + 1]);\n    }\n  }\n\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n} // function updateUnvisitedNeighbors(node, grid) {\n//   const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, 'bfs');\n//   for (const neighbor of unvisitedNeighbors) {\n//     neighbor.distance = node.distance + 1;\n//     neighbor.previousNode = node;\n//   }\n// }\n// function getNeighbors(id, boardArray, name) {\n//   let coordinates = id.split(\"-\");\n//   let x = parseInt(coordinates[0]);\n//   let y = parseInt(coordinates[1]);\n//   let neighbors = [];\n//   let potentialNeighbor;\n//   if (boardArray[x - 1] && boardArray[x - 1][y]) {\n//     potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`\n//     if (potentialNeighbor.isWall = false) {\n//       if (name === \"bfs\") {\n//         neighbors.push(potentialNeighbor);\n//       } else {\n//         neighbors.unshift(potentialNeighbor);\n//       }\n//     }\n//   }\n//   if (boardArray[x][y + 1]) {\n//     potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`\n//     if (potentialNeighbor.isWall = false) {\n//       if (name === \"bfs\") {\n//         neighbors.push(potentialNeighbor);\n//       } else {\n//         neighbors.unshift(potentialNeighbor);\n//       }\n//     }\n//   }\n//   if (boardArray[x + 1] && boardArray[x + 1][y]) {\n//     potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`\n//     if (potentialNeighbor.isWall = false) {\n//       if (name === \"bfs\") {\n//         neighbors.push(potentialNeighbor);\n//       } else {\n//         neighbors.unshift(potentialNeighbor);\n//       }\n//     }\n//   }\n//   if (boardArray[x][y - 1]) {\n//     potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`\n//     if (potentialNeighbor.isWall = false) {\n//       if (name === \"bfs\") {\n//         neighbors.push(potentialNeighbor);\n//       } else {\n//         neighbors.unshift(potentialNeighbor);\n//       }\n//     }\n//   }\n//   return neighbors;\n// }","map":{"version":3,"sources":["E:/minor project/Pathfinding-Algorithm-visualiser/Minor_project/src/Algorithms/BFS.jsx"],"names":["unweightedSearchAlgorithm","grid","startNode","finishNode","name","visitedNodesInOrder","structure","exploredNodes","length","currentNode","shift","pop","push","isVisited","currentNeighbors","getUnvisitedNeighbors","forEach","neighbor","previousNode","node","neighbors","col","row","unshift","filter"],"mappings":"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","sourcesContent":["// import {getAllNodes} from './AlgoTools';\r\n\r\n// export function bfs(grid,startNode,finishNode) {\r\n\r\n//   const queue = [];\r\n//   startNode.isVisited = true;\r\n//   queue.push(startNode);\r\n//   const unvisitedNodes = getAllNodes(grid);\r\n\r\n//   while(queue.length > 0) {\r\n//     let currentNode = queue.shift();\r\n//     queue.push(currentNode);\r\n//     currentNode.isVisited = true;\r\n//     if(currentNode == finishNode) {\r\n//       return queue;\r\n//     }\r\n//     sortNodesByDistance(unvisitedNodes);\r\n//     let edges = unvisitedNodes.shift();\r\n//     for (let i = 0; i < edges.length; i++){\r\n//       let neighbor = edges[i];\r\n//       if(!neighbor.isVisited) {\r\n//         neighbor.isVisited = true;\r\n//         neighbor.previousNode = current;\r\n//         queue.push(neighbor);\r\n//       }\r\n//     }\r\n//     updateUnvisitedNeighbors(edges, grid);\r\n//   }\r\n// }\r\n\r\nexport function unweightedSearchAlgorithm(grid, startNode, finishNode, name) {\r\n\r\n  const visitedNodesInOrder = [];\r\n  let structure = [startNode];\r\n  let exploredNodes = {startNode: true};\r\n  while (structure.length) {\r\n    let currentNode = name === \"bfs\" ? structure.shift() : structure.pop();\r\n    visitedNodesInOrder.push(currentNode);\r\n    if (name === \"dfs\") exploredNodes[currentNode]= true;\r\n    currentNode.isVisited = true;\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    let currentNeighbors = getUnvisitedNeighbors(currentNode, grid, name);\r\n    currentNeighbors.forEach(neighbor => {\r\n      if (!exploredNodes[neighbor]) {\r\n        if (name === \"bfs\") exploredNodes[neighbor] = true;\r\n        neighbor.previousNode = currentNode;\r\n        structure.push(neighbor);\r\n      }\r\n    });\r\n  }\r\n  return visitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid, name) {\r\n  const neighbors = [];\r\n  const {col, row} = node;\r\n\r\n  if (row > 0) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row - 1][col]);\r\n    } else {\r\n      neighbors.unshift(grid[row - 1][col]);\r\n    }\r\n  }\r\n\r\n  if (row < grid.length - 1) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row + 1][col]);\r\n    } else {\r\n      neighbors.unshift(grid[row + 1][col]);\r\n    }\r\n  } \r\n\r\n  if (col > 0) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row][col - 1]);\r\n    } else {\r\n      neighbors.unshift(grid[row][col - 1]);\r\n    }\r\n  } \r\n  if (col < grid[0].length - 1) {\r\n    if (name === \"bfs\") {\r\n      neighbors.push(grid[row][col + 1]);\r\n    } else {\r\n      neighbors.unshift(grid[row][col + 1]);\r\n    }\r\n  } \r\n  return neighbors.filter(neighbor => !neighbor.isVisited);\r\n}\r\n\r\n// function updateUnvisitedNeighbors(node, grid) {\r\n//   const unvisitedNeighbors = getUnvisitedNeighbors(node, grid, 'bfs');\r\n//   for (const neighbor of unvisitedNeighbors) {\r\n//     neighbor.distance = node.distance + 1;\r\n//     neighbor.previousNode = node;\r\n//   }\r\n// }\r\n\r\n// function getNeighbors(id, boardArray, name) {\r\n//   let coordinates = id.split(\"-\");\r\n//   let x = parseInt(coordinates[0]);\r\n//   let y = parseInt(coordinates[1]);\r\n//   let neighbors = [];\r\n//   let potentialNeighbor;\r\n//   if (boardArray[x - 1] && boardArray[x - 1][y]) {\r\n//     potentialNeighbor = `${(x - 1).toString()}-${y.toString()}`\r\n//     if (potentialNeighbor.isWall = false) {\r\n//       if (name === \"bfs\") {\r\n//         neighbors.push(potentialNeighbor);\r\n//       } else {\r\n//         neighbors.unshift(potentialNeighbor);\r\n//       }\r\n//     }\r\n//   }\r\n//   if (boardArray[x][y + 1]) {\r\n//     potentialNeighbor = `${x.toString()}-${(y + 1).toString()}`\r\n//     if (potentialNeighbor.isWall = false) {\r\n//       if (name === \"bfs\") {\r\n//         neighbors.push(potentialNeighbor);\r\n//       } else {\r\n//         neighbors.unshift(potentialNeighbor);\r\n//       }\r\n//     }\r\n//   }\r\n//   if (boardArray[x + 1] && boardArray[x + 1][y]) {\r\n//     potentialNeighbor = `${(x + 1).toString()}-${y.toString()}`\r\n//     if (potentialNeighbor.isWall = false) {\r\n//       if (name === \"bfs\") {\r\n//         neighbors.push(potentialNeighbor);\r\n//       } else {\r\n//         neighbors.unshift(potentialNeighbor);\r\n//       }\r\n//     }\r\n//   }\r\n//   if (boardArray[x][y - 1]) {\r\n//     potentialNeighbor = `${x.toString()}-${(y - 1).toString()}`\r\n//     if (potentialNeighbor.isWall = false) {\r\n//       if (name === \"bfs\") {\r\n//         neighbors.push(potentialNeighbor);\r\n//       } else {\r\n//         neighbors.unshift(potentialNeighbor);\r\n//       }\r\n//     }\r\n//   }\r\n//   return neighbors;\r\n// }\r\n"]},"metadata":{},"sourceType":"module"}